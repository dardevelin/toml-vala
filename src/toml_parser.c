/* toml_parser.c generated by valac 0.56.18, the Vala compiler
 * generated from toml_parser.vala, do not modify */

/*
 * toml_parser.vala
 * A feature-complete TOML v1.0.0 parser written in Vala.
 *
 * This parser implements the TOML specification available at https://toml.io/en/v1.0.0
 * It parses TOML strings into a tree of TomlValue objects.
 *
 * UTF-8 Support: The parser assumes the input TOML string is valid UTF-8 encoded.
 * It correctly handles Unicode characters in strings, keys, and comments.
 *
 * Easy API: Use TomlParser.parse_file(filename) to get a TomlValue tree.
 * TomlValue provides get(key) for tables and get_index(index) for arrays.
 *
 * Functional Design: Parsing is side-effect free, using immutable structures where possible.
 * The parser is self-cleaning with Vala's garbage collector managing memory.
 *
 * Copyright (c) 2025 Darcy Bras da Silva
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

#include <glib-object.h>
#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <float.h>
#include <math.h>
#include <gee.h>
#include <json-glib/json-glib.h>
#include <gobject/gvaluecollector.h>
#include <gio/gio.h>

#if !defined(VALA_STRICT_C)
#if !defined(__clang__) && defined(__GNUC__) && (__GNUC__ >= 14)
#pragma GCC diagnostic warning "-Wincompatible-pointer-types"
#elif defined(__clang__) && (__clang_major__ >= 16)
#pragma clang diagnostic ignored "-Wincompatible-function-pointer-types"
#pragma clang diagnostic ignored "-Wincompatible-pointer-types"
#endif
#endif
#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef enum  {
	TOML_TYPE_STRING,
	TOML_TYPE_INT,
	TOML_TYPE_FLOAT,
	TOML_TYPE_BOOL,
	TOML_TYPE_DATETIME,
	TOML_TYPE_ARRAY,
	TOML_TYPE_TABLE
} TomlType;

#define TYPE_TOML_TYPE (toml_type_get_type ())

#define TYPE_TOML_VALUE (toml_value_get_type ())
#define TOML_VALUE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOML_VALUE, TomlValue))
#define TOML_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOML_VALUE, TomlValueClass))
#define IS_TOML_VALUE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOML_VALUE))
#define IS_TOML_VALUE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOML_VALUE))
#define TOML_VALUE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOML_VALUE, TomlValueClass))

typedef struct _TomlValue TomlValue;
typedef struct _TomlValueClass TomlValueClass;
typedef struct _TomlValuePrivate TomlValuePrivate;
#define _g_free0(var) (var = (g_free (var), NULL))
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_string_free0(var) ((var == NULL) ? NULL : (var = (g_string_free (var, TRUE), NULL)))
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _toml_value_unref0(var) ((var == NULL) ? NULL : (var = (toml_value_unref (var), NULL)))
#define __vala_JsonNode_free0(var) ((var == NULL) ? NULL : (var = (_vala_JsonNode_free (var), NULL)))
#define _json_array_unref0(var) ((var == NULL) ? NULL : (var = (json_array_unref (var), NULL)))
#define _json_object_unref0(var) ((var == NULL) ? NULL : (var = (json_object_unref (var), NULL)))

#define TYPE_TOML_ERROR (toml_error_get_type ())
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))
typedef struct _ParamSpecTomlValue ParamSpecTomlValue;

#define TYPE_TOML_PARSER (toml_parser_get_type ())
#define TOML_PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOML_PARSER, TomlParser))
#define TOML_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOML_PARSER, TomlParserClass))
#define IS_TOML_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOML_PARSER))
#define IS_TOML_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOML_PARSER))
#define TOML_PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOML_PARSER, TomlParserClass))

typedef struct _TomlParser TomlParser;
typedef struct _TomlParserClass TomlParserClass;
typedef struct _TomlParserPrivate TomlParserPrivate;
#define _toml_parser_unref0(var) ((var == NULL) ? NULL : (var = (toml_parser_unref (var), NULL)))
typedef struct _TomlParserParseFileAsyncData TomlParserParseFileAsyncData;
typedef struct _TomlParserReadFileContentAsyncData TomlParserReadFileContentAsyncData;
typedef struct _ParamSpecTomlParser ParamSpecTomlParser;

#define TYPE_TOML_WATCHER (toml_watcher_get_type ())
#define TOML_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOML_WATCHER, TomlWatcher))
#define TOML_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOML_WATCHER, TomlWatcherClass))
#define IS_TOML_WATCHER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOML_WATCHER))
#define IS_TOML_WATCHER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOML_WATCHER))
#define TOML_WATCHER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOML_WATCHER, TomlWatcherClass))

typedef struct _TomlWatcher TomlWatcher;
typedef struct _TomlWatcherClass TomlWatcherClass;
typedef struct _TomlWatcherPrivate TomlWatcherPrivate;
typedef struct _ParamSpecTomlWatcher ParamSpecTomlWatcher;
enum  {
	TOML_WATCHER_CHANGED_SIGNAL,
	TOML_WATCHER_NUM_SIGNALS
};
static guint toml_watcher_signals[TOML_WATCHER_NUM_SIGNALS] = {0};

#define TYPE_TOML_VALIDATION_ERROR (toml_validation_error_get_type ())
#define TOML_VALIDATION_ERROR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOML_VALIDATION_ERROR, TomlValidationError))
#define TOML_VALIDATION_ERROR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOML_VALIDATION_ERROR, TomlValidationErrorClass))
#define IS_TOML_VALIDATION_ERROR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOML_VALIDATION_ERROR))
#define IS_TOML_VALIDATION_ERROR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOML_VALIDATION_ERROR))
#define TOML_VALIDATION_ERROR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOML_VALIDATION_ERROR, TomlValidationErrorClass))

typedef struct _TomlValidationError TomlValidationError;
typedef struct _TomlValidationErrorClass TomlValidationErrorClass;
typedef struct _TomlValidationErrorPrivate TomlValidationErrorPrivate;
typedef struct _ParamSpecTomlValidationError ParamSpecTomlValidationError;

#define TYPE_TOML_VALIDATOR (toml_validator_get_type ())
#define TOML_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOML_VALIDATOR, TomlValidator))
#define TOML_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOML_VALIDATOR, TomlValidatorClass))
#define IS_TOML_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOML_VALIDATOR))
#define IS_TOML_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOML_VALIDATOR))
#define TOML_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOML_VALIDATOR, TomlValidatorClass))

typedef struct _TomlValidator TomlValidator;
typedef struct _TomlValidatorClass TomlValidatorClass;
typedef struct _TomlValidatorPrivate TomlValidatorPrivate;
#define _toml_validation_error_unref0(var) ((var == NULL) ? NULL : (var = (toml_validation_error_unref (var), NULL)))
typedef struct _ParamSpecTomlValidator ParamSpecTomlValidator;

struct _TomlValue {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TomlValuePrivate * priv;
};

struct _TomlValueClass {
	GTypeClass parent_class;
	void (*finalize) (TomlValue *self);
};

struct _TomlValuePrivate {
	TomlType _val_type;
	gchar* _string_val;
	gint64 _int_val;
	gdouble _float_val;
	gboolean _bool_val;
	GeeArrayList* _array_val;
	GeeHashMap* _table_val;
};

typedef enum  {
	TOML_ERROR_INVALID_SYNTAX,
	TOML_ERROR_INVALID_VALUE,
	TOML_ERROR_DUPLICATE_KEY,
	TOML_ERROR_MISSING_KEY
} TomlError;
#define TOML_ERROR toml_error_quark ()

struct _ParamSpecTomlValue {
	GParamSpec parent_instance;
};

struct _TomlParser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TomlParserPrivate * priv;
};

struct _TomlParserClass {
	GTypeClass parent_class;
	void (*finalize) (TomlParser *self);
};

struct _TomlParserPrivate {
	gchar* input;
	gint pos;
	gint line;
	gint col;
};

struct _TomlParserParseFileAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	gchar* filename;
	gchar* encoding;
	TomlValue* result;
	gchar* content;
	gchar* _tmp0_;
	TomlParser* parser;
	const gchar* _tmp1_;
	TomlParser* _tmp2_;
	TomlValue* _tmp3_;
	TomlParser* _tmp4_;
	TomlValue* _tmp5_;
	TomlValue* _tmp6_;
	GError* _inner_error0_;
};

struct _TomlParserReadFileContentAsyncData {
	int _state_;
	GObject* _source_object_;
	GAsyncResult* _res_;
	GTask* _async_result;
	gchar* filename;
	gchar* encoding;
	gchar* result;
	GFile* file;
	GFile* _tmp0_;
	guint8* data;
	gint data_length1;
	gint _data_size_;
	GFile* _tmp1_;
	guint8* _tmp2_;
	gsize _tmp3_;
	gchar* _tmp4_;
	gchar* _tmp5_;
	guint8* _tmp6_;
	gint _tmp6__length1;
	gchar* _tmp7_;
	gchar* detected_encoding;
	gchar* _tmp8_;
	gboolean _tmp9_;
	const gchar* _tmp10_;
	const gchar* _tmp11_;
	guint8* _tmp12_;
	gint _tmp12__length1;
	gchar* _tmp13_;
	gsize bytes_read;
	gsize bytes_written;
	gchar* content;
	guint8* _tmp14_;
	gint _tmp14__length1;
	const gchar* _tmp15_;
	gsize _tmp16_;
	gsize _tmp17_;
	gchar* _tmp18_;
	const gchar* _tmp19_;
	GError* _tmp20_;
	GError* e;
	GError* _tmp21_;
	const gchar* _tmp22_;
	gchar* _tmp23_;
	gchar* _tmp24_;
	GError* _tmp25_;
	GError* _tmp26_;
	GError* _inner_error0_;
};

struct _ParamSpecTomlParser {
	GParamSpec parent_instance;
};

struct _TomlWatcher {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TomlWatcherPrivate * priv;
};

struct _TomlWatcherClass {
	GTypeClass parent_class;
	void (*finalize) (TomlWatcher *self);
};

struct _TomlWatcherPrivate {
	GFile* file;
	GFileMonitor* monitor;
	gboolean watching;
};

struct _ParamSpecTomlWatcher {
	GParamSpec parent_instance;
};

struct _TomlValidationError {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TomlValidationErrorPrivate * priv;
};

struct _TomlValidationErrorClass {
	GTypeClass parent_class;
	void (*finalize) (TomlValidationError *self);
};

struct _TomlValidationErrorPrivate {
	gchar* _message;
	gint _line;
	gint _col;
	gchar* _suggestion;
};

struct _ParamSpecTomlValidationError {
	GParamSpec parent_instance;
};

struct _TomlValidator {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TomlValidatorPrivate * priv;
};

struct _TomlValidatorClass {
	GTypeClass parent_class;
	void (*finalize) (TomlValidator *self);
};

struct _ParamSpecTomlValidator {
	GParamSpec parent_instance;
};

static gint TomlValue_private_offset;
static gpointer toml_value_parent_class = NULL;
static gint TomlParser_private_offset;
static gpointer toml_parser_parent_class = NULL;
static gint TomlWatcher_private_offset;
static gpointer toml_watcher_parent_class = NULL;
static gint TomlValidationError_private_offset;
static gpointer toml_validation_error_parent_class = NULL;
static gpointer toml_validator_parent_class = NULL;

VALA_EXTERN GType toml_type_get_type (void) G_GNUC_CONST ;
VALA_EXTERN gpointer toml_value_ref (gpointer instance);
VALA_EXTERN void toml_value_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_toml_value (const gchar* name,
                                   const gchar* nick,
                                   const gchar* blurb,
                                   GType object_type,
                                   GParamFlags flags);
VALA_EXTERN void value_set_toml_value (GValue* value,
                           gpointer v_object);
VALA_EXTERN void value_take_toml_value (GValue* value,
                            gpointer v_object);
VALA_EXTERN gpointer value_get_toml_value (const GValue* value);
VALA_EXTERN GType toml_value_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TomlValue, toml_value_unref)
VALA_EXTERN TomlValue* toml_value_new_string (const gchar* val);
VALA_EXTERN TomlValue* toml_value_construct_string (GType object_type,
                                        const gchar* val);
static void toml_value_set_val_type (TomlValue* self,
                              TomlType value);
static void toml_value_set_string_val (TomlValue* self,
                                const gchar* value);
VALA_EXTERN TomlValue* toml_value_new_int (gint64 val);
VALA_EXTERN TomlValue* toml_value_construct_int (GType object_type,
                                     gint64 val);
static void toml_value_set_int_val (TomlValue* self,
                             gint64 value);
VALA_EXTERN TomlValue* toml_value_new_float (gdouble val);
VALA_EXTERN TomlValue* toml_value_construct_float (GType object_type,
                                       gdouble val);
static void toml_value_set_float_val (TomlValue* self,
                               gdouble value);
VALA_EXTERN TomlValue* toml_value_new_bool (gboolean val);
VALA_EXTERN TomlValue* toml_value_construct_bool (GType object_type,
                                      gboolean val);
static void toml_value_set_bool_val (TomlValue* self,
                              gboolean value);
VALA_EXTERN TomlValue* toml_value_new_datetime (const gchar* val);
VALA_EXTERN TomlValue* toml_value_construct_datetime (GType object_type,
                                          const gchar* val);
VALA_EXTERN TomlValue* toml_value_new_array (GeeArrayList* val);
VALA_EXTERN TomlValue* toml_value_construct_array (GType object_type,
                                       GeeArrayList* val);
static void toml_value_set_array_val (TomlValue* self,
                               GeeArrayList* value);
VALA_EXTERN TomlValue* toml_value_new_table (GeeHashMap* val);
VALA_EXTERN TomlValue* toml_value_construct_table (GType object_type,
                                       GeeHashMap* val);
static void toml_value_set_table_val (TomlValue* self,
                               GeeHashMap* value);
VALA_EXTERN TomlValue* toml_value_get (TomlValue* self,
                           const gchar* key);
VALA_EXTERN TomlType toml_value_get_val_type (TomlValue* self);
VALA_EXTERN GeeHashMap* toml_value_get_table_val (TomlValue* self);
VALA_EXTERN TomlValue* toml_value_get_index (TomlValue* self,
                                 gint index);
VALA_EXTERN GeeArrayList* toml_value_get_array_val (TomlValue* self);
VALA_EXTERN gchar* toml_value_to_toml (TomlValue* self);
static void toml_value_to_toml_internal (TomlValue* self,
                                  GString* sb,
                                  const gchar* indent);
VALA_EXTERN const gchar* toml_value_get_string_val (TomlValue* self);
VALA_EXTERN gint64 toml_value_get_int_val (TomlValue* self);
VALA_EXTERN gdouble toml_value_get_float_val (TomlValue* self);
VALA_EXTERN gboolean toml_value_get_bool_val (TomlValue* self);
VALA_EXTERN gchar* toml_value_to_json (TomlValue* self);
static JsonNode* toml_value_to_json_node (TomlValue* self);
static void _vala_JsonNode_free (JsonNode* self);
static JsonNode* _vala_JsonNode_copy (JsonNode* self);
VALA_EXTERN GQuark toml_error_quark (void);
VALA_EXTERN GType toml_error_get_type (void) G_GNUC_CONST ;
VALA_EXTERN TomlValue* toml_value_from_json (const gchar* json,
                                 GError** error);
static TomlValue* toml_value_from_json_node (JsonNode* node,
                                      GError** error);
VALA_EXTERN TomlValue* toml_value_new (void);
VALA_EXTERN TomlValue* toml_value_construct (GType object_type);
static void toml_value_finalize (TomlValue * obj);
static GType toml_value_get_type_once (void);
VALA_EXTERN gpointer toml_parser_ref (gpointer instance);
VALA_EXTERN void toml_parser_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_toml_parser (const gchar* name,
                                    const gchar* nick,
                                    const gchar* blurb,
                                    GType object_type,
                                    GParamFlags flags);
VALA_EXTERN void value_set_toml_parser (GValue* value,
                            gpointer v_object);
VALA_EXTERN void value_take_toml_parser (GValue* value,
                             gpointer v_object);
VALA_EXTERN gpointer value_get_toml_parser (const GValue* value);
VALA_EXTERN GType toml_parser_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TomlParser, toml_parser_unref)
VALA_EXTERN TomlParser* toml_parser_new (const gchar* toml);
VALA_EXTERN TomlParser* toml_parser_construct (GType object_type,
                                   const gchar* toml);
VALA_EXTERN TomlValue* toml_parser_parse_file (const gchar* filename,
                                   const gchar* encoding,
                                   GError** error);
static gchar* toml_parser_read_file_content (const gchar* filename,
                                      const gchar* encoding,
                                      GError** error);
VALA_EXTERN TomlValue* toml_parser_parse (TomlParser* self,
                              GError** error);
static void toml_parser_parse_file_async_data_free (gpointer _data);
VALA_EXTERN void toml_parser_parse_file_async (const gchar* filename,
                                   const gchar* encoding,
                                   GAsyncReadyCallback _callback_,
                                   gpointer _user_data_);
VALA_EXTERN TomlValue* toml_parser_parse_file_finish (GAsyncResult* _res_,
                                          GError** error);
static gboolean toml_parser_parse_file_async_co (TomlParserParseFileAsyncData* _data_);
static void toml_parser_read_file_content_async (const gchar* filename,
                                          const gchar* encoding,
                                          GAsyncReadyCallback _callback_,
                                          gpointer _user_data_);
static gchar* toml_parser_read_file_content_finish (GAsyncResult* _res_,
                                             GError** error);
static void toml_parser_parse_file_async_ready (GObject* source_object,
                                         GAsyncResult* _res_,
                                         gpointer _user_data_);
static gchar toml_parser_peek (TomlParser* self);
static gchar toml_parser_next (TomlParser* self);
static void toml_parser_skip_whitespace (TomlParser* self);
static void toml_parser_skip_comment (TomlParser* self);
static gchar* toml_parser_parse_key (TomlParser* self,
                              GError** error);
static TomlValue* toml_parser_parse_value (TomlParser* self,
                                    GError** error);
static TomlValue* toml_parser_parse_string (TomlParser* self,
                                     GError** error);
static TomlValue* toml_parser_parse_literal_string (TomlParser* self,
                                             GError** error);
static TomlValue* toml_parser_parse_number (TomlParser* self,
                                     GError** error);
static TomlValue* toml_parser_parse_bool (TomlParser* self,
                                   GError** error);
static TomlValue* toml_parser_parse_array (TomlParser* self,
                                    GError** error);
static TomlValue* toml_parser_parse_inline_table (TomlParser* self,
                                           GError** error);
static GeeArrayList* toml_parser_parse_table_header (TomlParser* self,
                                              GError** error);
static GeeArrayList* toml_parser_parse_array_table_header (TomlParser* self,
                                                    GError** error);
static void toml_parser_set_nested_value (TomlParser* self,
                                   GeeHashMap* root,
                                   GeeArrayList* keys,
                                   TomlValue* val,
                                   gint start,
                                   GError** error);
static void toml_parser_add_to_array_table (TomlParser* self,
                                     GeeHashMap* root,
                                     GeeArrayList* keys,
                                     GeeHashMap* table,
                                     GError** error);
static void toml_parser_parse_table_content (TomlParser* self,
                                      GeeHashMap* table,
                                      GError** error);
static void toml_parser_parse_key_value (TomlParser* self,
                                  GeeHashMap* table,
                                  GError** error);
static gchar* toml_parser_detect_encoding (guint8* data,
                                    gint data_length1);
static void toml_parser_read_file_content_async_data_free (gpointer _data);
static gboolean toml_parser_read_file_content_async_co (TomlParserReadFileContentAsyncData* _data_);
static void toml_parser_read_file_content_async_ready (GObject* source_object,
                                                GAsyncResult* _res_,
                                                gpointer _user_data_);
static void toml_parser_finalize (TomlParser * obj);
static GType toml_parser_get_type_once (void);
VALA_EXTERN gpointer toml_watcher_ref (gpointer instance);
VALA_EXTERN void toml_watcher_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_toml_watcher (const gchar* name,
                                     const gchar* nick,
                                     const gchar* blurb,
                                     GType object_type,
                                     GParamFlags flags);
VALA_EXTERN void value_set_toml_watcher (GValue* value,
                             gpointer v_object);
VALA_EXTERN void value_take_toml_watcher (GValue* value,
                              gpointer v_object);
VALA_EXTERN gpointer value_get_toml_watcher (const GValue* value);
VALA_EXTERN GType toml_watcher_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TomlWatcher, toml_watcher_unref)
VALA_EXTERN TomlWatcher* toml_watcher_new (const gchar* filename);
VALA_EXTERN TomlWatcher* toml_watcher_construct (GType object_type,
                                     const gchar* filename);
VALA_EXTERN void toml_watcher_start (TomlWatcher* self,
                         GError** error);
static void toml_watcher_on_file_changed (TomlWatcher* self,
                                   GFile* file,
                                   GFile* other_file,
                                   GFileMonitorEvent event_type);
static void _toml_watcher_on_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                           GFile* file,
                                                           GFile* other_file,
                                                           GFileMonitorEvent event_type,
                                                           gpointer self);
VALA_EXTERN void toml_watcher_stop (TomlWatcher* self);
static void g_cclosure_user_marshal_VOID__TOML_VALUE (GClosure * closure,
                                               GValue * return_value,
                                               guint n_param_values,
                                               const GValue * param_values,
                                               gpointer invocation_hint,
                                               gpointer marshal_data);
static void toml_watcher_finalize (TomlWatcher * obj);
static GType toml_watcher_get_type_once (void);
VALA_EXTERN gpointer toml_validation_error_ref (gpointer instance);
VALA_EXTERN void toml_validation_error_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_toml_validation_error (const gchar* name,
                                              const gchar* nick,
                                              const gchar* blurb,
                                              GType object_type,
                                              GParamFlags flags);
VALA_EXTERN void value_set_toml_validation_error (GValue* value,
                                      gpointer v_object);
VALA_EXTERN void value_take_toml_validation_error (GValue* value,
                                       gpointer v_object);
VALA_EXTERN gpointer value_get_toml_validation_error (const GValue* value);
VALA_EXTERN GType toml_validation_error_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TomlValidationError, toml_validation_error_unref)
VALA_EXTERN TomlValidationError* toml_validation_error_new (const gchar* msg,
                                                gint l,
                                                gint c,
                                                const gchar* sugg);
VALA_EXTERN TomlValidationError* toml_validation_error_construct (GType object_type,
                                                      const gchar* msg,
                                                      gint l,
                                                      gint c,
                                                      const gchar* sugg);
static void toml_validation_error_set_message (TomlValidationError* self,
                                        const gchar* value);
static void toml_validation_error_set_line (TomlValidationError* self,
                                     gint value);
static void toml_validation_error_set_col (TomlValidationError* self,
                                    gint value);
static void toml_validation_error_set_suggestion (TomlValidationError* self,
                                           const gchar* value);
VALA_EXTERN const gchar* toml_validation_error_get_message (TomlValidationError* self);
VALA_EXTERN gint toml_validation_error_get_line (TomlValidationError* self);
VALA_EXTERN gint toml_validation_error_get_col (TomlValidationError* self);
VALA_EXTERN const gchar* toml_validation_error_get_suggestion (TomlValidationError* self);
static void toml_validation_error_finalize (TomlValidationError * obj);
static GType toml_validation_error_get_type_once (void);
VALA_EXTERN gpointer toml_validator_ref (gpointer instance);
VALA_EXTERN void toml_validator_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_toml_validator (const gchar* name,
                                       const gchar* nick,
                                       const gchar* blurb,
                                       GType object_type,
                                       GParamFlags flags);
VALA_EXTERN void value_set_toml_validator (GValue* value,
                               gpointer v_object);
VALA_EXTERN void value_take_toml_validator (GValue* value,
                                gpointer v_object);
VALA_EXTERN gpointer value_get_toml_validator (const GValue* value);
VALA_EXTERN GType toml_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (TomlValidator, toml_validator_unref)
VALA_EXTERN GeeArrayList* toml_validator_validate_file (const gchar* filename,
                                            const gchar* encoding);
VALA_EXTERN TomlValidator* toml_validator_new (void);
VALA_EXTERN TomlValidator* toml_validator_construct (GType object_type);
static void toml_validator_finalize (TomlValidator * obj);
static GType toml_validator_get_type_once (void);

static GType
toml_type_get_type_once (void)
{
	static const GEnumValue values[] = {{TOML_TYPE_STRING, "TOML_TYPE_STRING", "string"}, {TOML_TYPE_INT, "TOML_TYPE_INT", "int"}, {TOML_TYPE_FLOAT, "TOML_TYPE_FLOAT", "float"}, {TOML_TYPE_BOOL, "TOML_TYPE_BOOL", "bool"}, {TOML_TYPE_DATETIME, "TOML_TYPE_DATETIME", "datetime"}, {TOML_TYPE_ARRAY, "TOML_TYPE_ARRAY", "array"}, {TOML_TYPE_TABLE, "TOML_TYPE_TABLE", "table"}, {0, NULL, NULL}};
	GType toml_type_type_id;
	toml_type_type_id = g_enum_register_static ("TomlType", values);
	return toml_type_type_id;
}

GType
toml_type_get_type (void)
{
	static volatile gsize toml_type_type_id__once = 0;
	if (g_once_init_enter (&toml_type_type_id__once)) {
		GType toml_type_type_id;
		toml_type_type_id = toml_type_get_type_once ();
		g_once_init_leave (&toml_type_type_id__once, toml_type_type_id);
	}
	return toml_type_type_id__once;
}

static inline gpointer
toml_value_get_instance_private (TomlValue* self)
{
	return G_STRUCT_MEMBER_P (self, TomlValue_private_offset);
}

TomlValue*
toml_value_construct_string (GType object_type,
                             const gchar* val)
{
	TomlValue* self = NULL;
	g_return_val_if_fail (val != NULL, NULL);
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_STRING);
	toml_value_set_string_val (self, val);
	return self;
}

TomlValue*
toml_value_new_string (const gchar* val)
{
	return toml_value_construct_string (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_int (GType object_type,
                          gint64 val)
{
	TomlValue* self = NULL;
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_INT);
	toml_value_set_int_val (self, val);
	return self;
}

TomlValue*
toml_value_new_int (gint64 val)
{
	return toml_value_construct_int (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_float (GType object_type,
                            gdouble val)
{
	TomlValue* self = NULL;
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_FLOAT);
	toml_value_set_float_val (self, val);
	return self;
}

TomlValue*
toml_value_new_float (gdouble val)
{
	return toml_value_construct_float (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_bool (GType object_type,
                           gboolean val)
{
	TomlValue* self = NULL;
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_BOOL);
	toml_value_set_bool_val (self, val);
	return self;
}

TomlValue*
toml_value_new_bool (gboolean val)
{
	return toml_value_construct_bool (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_datetime (GType object_type,
                               const gchar* val)
{
	TomlValue* self = NULL;
	g_return_val_if_fail (val != NULL, NULL);
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_DATETIME);
	toml_value_set_string_val (self, val);
	return self;
}

TomlValue*
toml_value_new_datetime (const gchar* val)
{
	return toml_value_construct_datetime (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_array (GType object_type,
                            GeeArrayList* val)
{
	TomlValue* self = NULL;
	g_return_val_if_fail (val != NULL, NULL);
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_ARRAY);
	toml_value_set_array_val (self, val);
	return self;
}

TomlValue*
toml_value_new_array (GeeArrayList* val)
{
	return toml_value_construct_array (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_construct_table (GType object_type,
                            GeeHashMap* val)
{
	TomlValue* self = NULL;
	g_return_val_if_fail (val != NULL, NULL);
	self = (TomlValue*) g_type_create_instance (object_type);
	toml_value_set_val_type (self, TOML_TYPE_TABLE);
	toml_value_set_table_val (self, val);
	return self;
}

TomlValue*
toml_value_new_table (GeeHashMap* val)
{
	return toml_value_construct_table (TYPE_TOML_VALUE, val);
}

TomlValue*
toml_value_get (TomlValue* self,
                const gchar* key)
{
	gboolean _tmp0_ = FALSE;
	TomlType _tmp1_;
	GeeHashMap* _tmp3_;
	gpointer _tmp4_;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (key != NULL, NULL);
	_tmp1_ = self->priv->_val_type;
	if (_tmp1_ != TOML_TYPE_TABLE) {
		_tmp0_ = TRUE;
	} else {
		GeeHashMap* _tmp2_;
		_tmp2_ = self->priv->_table_val;
		_tmp0_ = _tmp2_ == NULL;
	}
	if (_tmp0_) {
		result = NULL;
		return result;
	}
	_tmp3_ = self->priv->_table_val;
	_tmp4_ = gee_abstract_map_get ((GeeAbstractMap*) _tmp3_, key);
	result = (TomlValue*) _tmp4_;
	return result;
}

TomlValue*
toml_value_get_index (TomlValue* self,
                      gint index)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	gboolean _tmp2_ = FALSE;
	TomlType _tmp3_;
	GeeArrayList* _tmp8_;
	gpointer _tmp9_;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp3_ = self->priv->_val_type;
	if (_tmp3_ != TOML_TYPE_ARRAY) {
		_tmp2_ = TRUE;
	} else {
		GeeArrayList* _tmp4_;
		_tmp4_ = self->priv->_array_val;
		_tmp2_ = _tmp4_ == NULL;
	}
	if (_tmp2_) {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = index < 0;
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		GeeArrayList* _tmp5_;
		gint _tmp6_;
		gint _tmp7_;
		_tmp5_ = self->priv->_array_val;
		_tmp6_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp5_);
		_tmp7_ = _tmp6_;
		_tmp0_ = index >= _tmp7_;
	}
	if (_tmp0_) {
		result = NULL;
		return result;
	}
	_tmp8_ = self->priv->_array_val;
	_tmp9_ = gee_abstract_list_get ((GeeAbstractList*) _tmp8_, index);
	result = (TomlValue*) _tmp9_;
	return result;
}

gchar*
toml_value_to_toml (TomlValue* self)
{
	GString* sb = NULL;
	GString* _tmp0_;
	const gchar* _tmp1_;
	gchar* _tmp2_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	toml_value_to_toml_internal (self, sb, "");
	_tmp1_ = sb->str;
	_tmp2_ = g_strdup (_tmp1_);
	result = _tmp2_;
	_g_string_free0 (sb);
	return result;
}

static gchar*
string_replace (const gchar* self,
                const gchar* old,
                const gchar* replacement)
{
	gboolean _tmp0_ = FALSE;
	gboolean _tmp1_ = FALSE;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	if ((*((gchar*) self)) == '\0') {
		_tmp1_ = TRUE;
	} else {
		_tmp1_ = (*((gchar*) old)) == '\0';
	}
	if (_tmp1_) {
		_tmp0_ = TRUE;
	} else {
		_tmp0_ = g_strcmp0 (old, replacement) == 0;
	}
	if (_tmp0_) {
		gchar* _tmp2_;
		_tmp2_ = g_strdup (self);
		result = _tmp2_;
		return result;
	}
	{
		GRegex* regex = NULL;
		gchar* _tmp3_;
		gchar* _tmp4_;
		GRegex* _tmp5_;
		GRegex* _tmp6_;
		gchar* _tmp7_ = NULL;
		GRegex* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		_tmp3_ = g_regex_escape_string (old, -1);
		_tmp4_ = _tmp3_;
		_tmp5_ = g_regex_new (_tmp4_, 0, 0, &_inner_error0_);
		_tmp6_ = _tmp5_;
		_g_free0 (_tmp4_);
		regex = _tmp6_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp8_ = regex;
		_tmp9_ = g_regex_replace_literal (_tmp8_, self, (gssize) -1, 0, replacement, 0, &_inner_error0_);
		_tmp7_ = _tmp9_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_regex_unref0 (regex);
			if (_inner_error0_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
		_tmp10_ = _tmp7_;
		_tmp7_ = NULL;
		result = _tmp10_;
		_g_free0 (_tmp7_);
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		g_clear_error (&_inner_error0_);
		g_assert_not_reached ();
	}
	__finally0:
	g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
	g_clear_error (&_inner_error0_);
	return NULL;
}

static gchar*
double_to_string (gdouble self)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gint _tmp1__length1;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* result;
	_tmp0_ = g_new0 (gchar, G_ASCII_DTOSTR_BUF_SIZE);
	_tmp1_ = _tmp0_;
	_tmp1__length1 = G_ASCII_DTOSTR_BUF_SIZE;
	_tmp2_ = g_ascii_dtostr (_tmp1_, (gint) G_ASCII_DTOSTR_BUF_SIZE, self);
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_tmp1_ = (g_free (_tmp1_), NULL);
	result = _tmp4_;
	return result;
}

static void
toml_value_to_toml_internal (TomlValue* self,
                             GString* sb,
                             const gchar* indent)
{
	TomlType _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sb != NULL);
	g_return_if_fail (indent != NULL);
	_tmp0_ = self->priv->_val_type;
	switch (_tmp0_) {
		case TOML_TYPE_STRING:
		{
			const gchar* _tmp1_;
			gchar* _tmp2_;
			gchar* _tmp3_;
			gchar* _tmp4_;
			gchar* _tmp5_;
			gchar* _tmp6_;
			gchar* _tmp7_;
			_tmp1_ = self->priv->_string_val;
			_tmp2_ = string_replace (_tmp1_, "\"", "\\\"");
			_tmp3_ = _tmp2_;
			_tmp4_ = g_strconcat ("\"", _tmp3_, NULL);
			_tmp5_ = _tmp4_;
			_tmp6_ = g_strconcat (_tmp5_, "\"", NULL);
			_tmp7_ = _tmp6_;
			g_string_append (sb, _tmp7_);
			_g_free0 (_tmp7_);
			_g_free0 (_tmp5_);
			_g_free0 (_tmp3_);
			break;
		}
		case TOML_TYPE_INT:
		{
			gint64 _tmp8_;
			gchar* _tmp9_;
			gchar* _tmp10_;
			_tmp8_ = self->priv->_int_val;
			_tmp9_ = g_strdup_printf ("%" G_GINT64_FORMAT, _tmp8_);
			_tmp10_ = _tmp9_;
			g_string_append (sb, _tmp10_);
			_g_free0 (_tmp10_);
			break;
		}
		case TOML_TYPE_FLOAT:
		{
			gdouble _tmp11_;
			gchar* _tmp12_;
			gchar* _tmp13_;
			_tmp11_ = self->priv->_float_val;
			_tmp12_ = double_to_string (_tmp11_);
			_tmp13_ = _tmp12_;
			g_string_append (sb, _tmp13_);
			_g_free0 (_tmp13_);
			break;
		}
		case TOML_TYPE_BOOL:
		{
			const gchar* _tmp14_ = NULL;
			gboolean _tmp15_;
			_tmp15_ = self->priv->_bool_val;
			if (_tmp15_) {
				_tmp14_ = "true";
			} else {
				_tmp14_ = "false";
			}
			g_string_append (sb, _tmp14_);
			break;
		}
		case TOML_TYPE_DATETIME:
		{
			const gchar* _tmp16_;
			_tmp16_ = self->priv->_string_val;
			g_string_append (sb, _tmp16_);
			break;
		}
		case TOML_TYPE_ARRAY:
		{
			g_string_append (sb, "[");
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp17_ = FALSE;
					_tmp17_ = TRUE;
					while (TRUE) {
						GeeArrayList* _tmp19_;
						gint _tmp20_;
						gint _tmp21_;
						GeeArrayList* _tmp22_;
						gpointer _tmp23_;
						TomlValue* _tmp24_;
						if (!_tmp17_) {
							gint _tmp18_;
							_tmp18_ = i;
							i = _tmp18_ + 1;
						}
						_tmp17_ = FALSE;
						_tmp19_ = self->priv->_array_val;
						_tmp20_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp19_);
						_tmp21_ = _tmp20_;
						if (!(i < _tmp21_)) {
							break;
						}
						if (i > 0) {
							g_string_append (sb, ", ");
						}
						_tmp22_ = self->priv->_array_val;
						_tmp23_ = gee_abstract_list_get ((GeeAbstractList*) _tmp22_, i);
						_tmp24_ = (TomlValue*) _tmp23_;
						toml_value_to_toml_internal (_tmp24_, sb, indent);
						_toml_value_unref0 (_tmp24_);
					}
				}
			}
			g_string_append (sb, "]");
			break;
		}
		case TOML_TYPE_TABLE:
		{
			{
				GeeIterator* _entry_it = NULL;
				GeeHashMap* _tmp25_;
				GeeSet* _tmp26_;
				GeeSet* _tmp27_;
				GeeSet* _tmp28_;
				GeeIterator* _tmp29_;
				GeeIterator* _tmp30_;
				_tmp25_ = self->priv->_table_val;
				_tmp26_ = gee_abstract_map_get_entries ((GeeAbstractMap*) _tmp25_);
				_tmp27_ = _tmp26_;
				_tmp28_ = _tmp27_;
				_tmp29_ = gee_iterable_iterator ((GeeIterable*) _tmp28_);
				_tmp30_ = _tmp29_;
				_g_object_unref0 (_tmp28_);
				_entry_it = _tmp30_;
				while (TRUE) {
					GeeIterator* _tmp31_;
					GeeMapEntry* entry = NULL;
					GeeIterator* _tmp32_;
					gpointer _tmp33_;
					GeeMapEntry* _tmp34_;
					gconstpointer _tmp35_;
					gconstpointer _tmp36_;
					gchar* _tmp37_;
					gchar* _tmp38_;
					gchar* _tmp39_;
					gchar* _tmp40_;
					GeeMapEntry* _tmp41_;
					gconstpointer _tmp42_;
					gconstpointer _tmp43_;
					_tmp31_ = _entry_it;
					if (!gee_iterator_next (_tmp31_)) {
						break;
					}
					_tmp32_ = _entry_it;
					_tmp33_ = gee_iterator_get (_tmp32_);
					entry = (GeeMapEntry*) _tmp33_;
					_tmp34_ = entry;
					_tmp35_ = gee_map_entry_get_key (_tmp34_);
					_tmp36_ = _tmp35_;
					_tmp37_ = g_strconcat (indent, (const gchar*) _tmp36_, NULL);
					_tmp38_ = _tmp37_;
					_tmp39_ = g_strconcat (_tmp38_, " = ", NULL);
					_tmp40_ = _tmp39_;
					g_string_append (sb, _tmp40_);
					_g_free0 (_tmp40_);
					_g_free0 (_tmp38_);
					_tmp41_ = entry;
					_tmp42_ = gee_map_entry_get_value (_tmp41_);
					_tmp43_ = _tmp42_;
					toml_value_to_toml_internal ((TomlValue*) _tmp43_, sb, indent);
					g_string_append (sb, "\n");
					_g_object_unref0 (entry);
				}
				_g_object_unref0 (_entry_it);
			}
			break;
		}
		default:
		break;
	}
}

static void
_vala_JsonNode_free (JsonNode* self)
{
	g_boxed_free (json_node_get_type (), self);
}

gchar*
toml_value_to_json (TomlValue* self)
{
	JsonNode* _tmp0_;
	JsonNode* _tmp1_;
	gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = toml_value_to_json_node (self);
	_tmp1_ = _tmp0_;
	_tmp2_ = json_to_string (_tmp1_, FALSE);
	_tmp3_ = _tmp2_;
	__vala_JsonNode_free0 (_tmp1_);
	result = _tmp3_;
	return result;
}

static JsonNode*
_vala_JsonNode_copy (JsonNode* self)
{
	return g_boxed_copy (json_node_get_type (), self);
}

static gpointer
__vala_JsonNode_copy0 (gpointer self)
{
	return self ? _vala_JsonNode_copy (self) : NULL;
}

static JsonNode*
toml_value_to_json_node (TomlValue* self)
{
	TomlType _tmp0_;
	JsonNode* _tmp73_;
	JsonNode* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_val_type;
	switch (_tmp0_) {
		case TOML_TYPE_STRING:
		{
			JsonNode* _tmp1_;
			JsonNode* _tmp2_;
			const gchar* _tmp3_;
			JsonNode* _tmp4_;
			JsonNode* _tmp5_;
			JsonNode* _tmp6_;
			_tmp1_ = json_node_new (JSON_NODE_VALUE);
			_tmp2_ = _tmp1_;
			_tmp3_ = self->priv->_string_val;
			_tmp4_ = json_node_init_string (_tmp2_, _tmp3_);
			_tmp5_ = __vala_JsonNode_copy0 (_tmp4_);
			_tmp6_ = _tmp5_;
			__vala_JsonNode_free0 (_tmp2_);
			result = _tmp6_;
			return result;
		}
		case TOML_TYPE_INT:
		{
			JsonNode* _tmp7_;
			JsonNode* _tmp8_;
			gint64 _tmp9_;
			JsonNode* _tmp10_;
			JsonNode* _tmp11_;
			JsonNode* _tmp12_;
			_tmp7_ = json_node_new (JSON_NODE_VALUE);
			_tmp8_ = _tmp7_;
			_tmp9_ = self->priv->_int_val;
			_tmp10_ = json_node_init_int (_tmp8_, _tmp9_);
			_tmp11_ = __vala_JsonNode_copy0 (_tmp10_);
			_tmp12_ = _tmp11_;
			__vala_JsonNode_free0 (_tmp8_);
			result = _tmp12_;
			return result;
		}
		case TOML_TYPE_FLOAT:
		{
			JsonNode* _tmp13_;
			JsonNode* _tmp14_;
			gdouble _tmp15_;
			JsonNode* _tmp16_;
			JsonNode* _tmp17_;
			JsonNode* _tmp18_;
			_tmp13_ = json_node_new (JSON_NODE_VALUE);
			_tmp14_ = _tmp13_;
			_tmp15_ = self->priv->_float_val;
			_tmp16_ = json_node_init_double (_tmp14_, _tmp15_);
			_tmp17_ = __vala_JsonNode_copy0 (_tmp16_);
			_tmp18_ = _tmp17_;
			__vala_JsonNode_free0 (_tmp14_);
			result = _tmp18_;
			return result;
		}
		case TOML_TYPE_BOOL:
		{
			JsonNode* _tmp19_;
			JsonNode* _tmp20_;
			gboolean _tmp21_;
			JsonNode* _tmp22_;
			JsonNode* _tmp23_;
			JsonNode* _tmp24_;
			_tmp19_ = json_node_new (JSON_NODE_VALUE);
			_tmp20_ = _tmp19_;
			_tmp21_ = self->priv->_bool_val;
			_tmp22_ = json_node_init_boolean (_tmp20_, _tmp21_);
			_tmp23_ = __vala_JsonNode_copy0 (_tmp22_);
			_tmp24_ = _tmp23_;
			__vala_JsonNode_free0 (_tmp20_);
			result = _tmp24_;
			return result;
		}
		case TOML_TYPE_DATETIME:
		{
			JsonNode* _tmp25_;
			JsonNode* _tmp26_;
			const gchar* _tmp27_;
			JsonNode* _tmp28_;
			JsonNode* _tmp29_;
			JsonNode* _tmp30_;
			_tmp25_ = json_node_new (JSON_NODE_VALUE);
			_tmp26_ = _tmp25_;
			_tmp27_ = self->priv->_string_val;
			_tmp28_ = json_node_init_string (_tmp26_, _tmp27_);
			_tmp29_ = __vala_JsonNode_copy0 (_tmp28_);
			_tmp30_ = _tmp29_;
			__vala_JsonNode_free0 (_tmp26_);
			result = _tmp30_;
			return result;
		}
		case TOML_TYPE_ARRAY:
		{
			JsonArray* array = NULL;
			JsonArray* _tmp31_;
			JsonNode* _tmp43_;
			JsonNode* _tmp44_;
			JsonArray* _tmp45_;
			JsonNode* _tmp46_;
			JsonNode* _tmp47_;
			JsonNode* _tmp48_;
			_tmp31_ = json_array_new ();
			array = _tmp31_;
			{
				GeeArrayList* _val_list = NULL;
				GeeArrayList* _tmp32_;
				gint _val_size = 0;
				GeeArrayList* _tmp33_;
				gint _tmp34_;
				gint _tmp35_;
				gint _val_index = 0;
				_tmp32_ = self->priv->_array_val;
				_val_list = _tmp32_;
				_tmp33_ = _val_list;
				_tmp34_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) _tmp33_);
				_tmp35_ = _tmp34_;
				_val_size = _tmp35_;
				_val_index = -1;
				while (TRUE) {
					gint _tmp36_;
					gint _tmp37_;
					TomlValue* val = NULL;
					GeeArrayList* _tmp38_;
					gpointer _tmp39_;
					JsonArray* _tmp40_;
					TomlValue* _tmp41_;
					JsonNode* _tmp42_;
					_val_index = _val_index + 1;
					_tmp36_ = _val_index;
					_tmp37_ = _val_size;
					if (!(_tmp36_ < _tmp37_)) {
						break;
					}
					_tmp38_ = _val_list;
					_tmp39_ = gee_abstract_list_get ((GeeAbstractList*) _tmp38_, _val_index);
					val = (TomlValue*) _tmp39_;
					_tmp40_ = array;
					_tmp41_ = val;
					_tmp42_ = toml_value_to_json_node (_tmp41_);
					json_array_add_element (_tmp40_, _tmp42_);
					_toml_value_unref0 (val);
				}
			}
			_tmp43_ = json_node_new (JSON_NODE_ARRAY);
			_tmp44_ = _tmp43_;
			_tmp45_ = array;
			_tmp46_ = json_node_init_array (_tmp44_, _tmp45_);
			_tmp47_ = __vala_JsonNode_copy0 (_tmp46_);
			_tmp48_ = _tmp47_;
			__vala_JsonNode_free0 (_tmp44_);
			result = _tmp48_;
			_json_array_unref0 (array);
			return result;
		}
		case TOML_TYPE_TABLE:
		{
			JsonObject* obj = NULL;
			JsonObject* _tmp49_;
			JsonNode* _tmp67_;
			JsonNode* _tmp68_;
			JsonObject* _tmp69_;
			JsonNode* _tmp70_;
			JsonNode* _tmp71_;
			JsonNode* _tmp72_;
			_tmp49_ = json_object_new ();
			obj = _tmp49_;
			{
				GeeIterator* _entry_it = NULL;
				GeeHashMap* _tmp50_;
				GeeSet* _tmp51_;
				GeeSet* _tmp52_;
				GeeSet* _tmp53_;
				GeeIterator* _tmp54_;
				GeeIterator* _tmp55_;
				_tmp50_ = self->priv->_table_val;
				_tmp51_ = gee_abstract_map_get_entries ((GeeAbstractMap*) _tmp50_);
				_tmp52_ = _tmp51_;
				_tmp53_ = _tmp52_;
				_tmp54_ = gee_iterable_iterator ((GeeIterable*) _tmp53_);
				_tmp55_ = _tmp54_;
				_g_object_unref0 (_tmp53_);
				_entry_it = _tmp55_;
				while (TRUE) {
					GeeIterator* _tmp56_;
					GeeMapEntry* entry = NULL;
					GeeIterator* _tmp57_;
					gpointer _tmp58_;
					JsonObject* _tmp59_;
					GeeMapEntry* _tmp60_;
					gconstpointer _tmp61_;
					gconstpointer _tmp62_;
					GeeMapEntry* _tmp63_;
					gconstpointer _tmp64_;
					gconstpointer _tmp65_;
					JsonNode* _tmp66_;
					_tmp56_ = _entry_it;
					if (!gee_iterator_next (_tmp56_)) {
						break;
					}
					_tmp57_ = _entry_it;
					_tmp58_ = gee_iterator_get (_tmp57_);
					entry = (GeeMapEntry*) _tmp58_;
					_tmp59_ = obj;
					_tmp60_ = entry;
					_tmp61_ = gee_map_entry_get_key (_tmp60_);
					_tmp62_ = _tmp61_;
					_tmp63_ = entry;
					_tmp64_ = gee_map_entry_get_value (_tmp63_);
					_tmp65_ = _tmp64_;
					_tmp66_ = toml_value_to_json_node ((TomlValue*) _tmp65_);
					json_object_set_member (_tmp59_, (const gchar*) _tmp62_, _tmp66_);
					_g_object_unref0 (entry);
				}
				_g_object_unref0 (_entry_it);
			}
			_tmp67_ = json_node_new (JSON_NODE_OBJECT);
			_tmp68_ = _tmp67_;
			_tmp69_ = obj;
			_tmp70_ = json_node_init_object (_tmp68_, _tmp69_);
			_tmp71_ = __vala_JsonNode_copy0 (_tmp70_);
			_tmp72_ = _tmp71_;
			__vala_JsonNode_free0 (_tmp68_);
			result = _tmp72_;
			_json_object_unref0 (obj);
			return result;
		}
		default:
		break;
	}
	_tmp73_ = json_node_new (JSON_NODE_NULL);
	result = _tmp73_;
	return result;
}

TomlValue*
toml_value_from_json (const gchar* json,
                      GError** error)
{
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (json != NULL, NULL);
	{
		JsonParser* parser = NULL;
		JsonParser* _tmp0_;
		JsonParser* _tmp1_;
		TomlValue* _tmp2_ = NULL;
		JsonParser* _tmp3_;
		JsonNode* _tmp4_;
		TomlValue* _tmp5_;
		TomlValue* _tmp6_;
		_tmp0_ = json_parser_new ();
		parser = _tmp0_;
		_tmp1_ = parser;
		json_parser_load_from_data (_tmp1_, json, (gssize) -1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (parser);
			goto __catch0_g_error;
		}
		_tmp3_ = parser;
		_tmp4_ = json_parser_get_root (_tmp3_);
		_tmp5_ = toml_value_from_json_node (_tmp4_, &_inner_error0_);
		_tmp2_ = _tmp5_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			_g_object_unref0 (parser);
			goto __catch0_g_error;
		}
		_tmp6_ = _tmp2_;
		_tmp2_ = NULL;
		result = _tmp6_;
		_toml_value_unref0 (_tmp2_);
		_g_object_unref0 (parser);
		return result;
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp7_;
		const gchar* _tmp8_;
		gchar* _tmp9_;
		gchar* _tmp10_;
		GError* _tmp11_;
		GError* _tmp12_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp7_ = e;
		_tmp8_ = _tmp7_->message;
		_tmp9_ = g_strconcat ("Invalid JSON: ", _tmp8_, NULL);
		_tmp10_ = _tmp9_;
		_tmp11_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, _tmp10_);
		_tmp12_ = _tmp11_;
		_g_free0 (_tmp10_);
		_inner_error0_ = _tmp12_;
		_g_error_free0 (e);
		goto __finally0;
	}
	__finally0:
	if (_inner_error0_->domain == TOML_ERROR) {
		g_propagate_error (error, _inner_error0_);
		return NULL;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
}

static gpointer
_json_array_ref0 (gpointer self)
{
	return self ? json_array_ref (self) : NULL;
}

static gpointer
_json_object_ref0 (gpointer self)
{
	return self ? json_object_ref (self) : NULL;
}

static TomlValue*
toml_value_from_json_node (JsonNode* node,
                           GError** error)
{
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (node != NULL, NULL);
	switch (json_node_get_node_type (node)) {
		case JSON_NODE_VALUE:
		{
			GValue val = {0};
			GValue _tmp0_ = {0};
			json_node_get_value (node, &_tmp0_);
			val = _tmp0_;
			if (G_VALUE_TYPE (&val) == G_TYPE_STRING) {
				const gchar* _tmp1_;
				TomlValue* _tmp2_;
				_tmp1_ = g_value_get_string (&val);
				_tmp2_ = toml_value_new_string (_tmp1_);
				result = _tmp2_;
				G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
				return result;
			} else {
				if (G_VALUE_TYPE (&val) == G_TYPE_INT64) {
					TomlValue* _tmp3_;
					_tmp3_ = toml_value_new_int ((gint64) g_value_get_int (&val));
					result = _tmp3_;
					G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
					return result;
				} else {
					if (G_VALUE_TYPE (&val) == G_TYPE_DOUBLE) {
						TomlValue* _tmp4_;
						_tmp4_ = toml_value_new_float (g_value_get_double (&val));
						result = _tmp4_;
						G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
						return result;
					} else {
						if (G_VALUE_TYPE (&val) == G_TYPE_BOOLEAN) {
							TomlValue* _tmp5_;
							_tmp5_ = toml_value_new_bool (g_value_get_boolean (&val));
							result = _tmp5_;
							G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
							return result;
						} else {
							GError* _tmp6_;
							_tmp6_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_VALUE, "Unsupported JSON value type");
							_inner_error0_ = _tmp6_;
							if (_inner_error0_->domain == TOML_ERROR) {
								g_propagate_error (error, _inner_error0_);
								G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
								return NULL;
							} else {
								G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
								g_clear_error (&_inner_error0_);
								return NULL;
							}
						}
					}
				}
			}
			G_IS_VALUE (&val) ? (g_value_unset (&val), NULL) : NULL;
		}
		case JSON_NODE_ARRAY:
		{
			GeeArrayList* array = NULL;
			GeeArrayList* _tmp7_;
			JsonArray* json_array = NULL;
			JsonArray* _tmp8_;
			JsonArray* _tmp9_;
			GeeArrayList* _tmp18_;
			TomlValue* _tmp19_;
			_tmp7_ = gee_array_list_new (TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL);
			array = _tmp7_;
			_tmp8_ = json_node_get_array (node);
			_tmp9_ = _json_array_ref0 (_tmp8_);
			json_array = _tmp9_;
			{
				gint i = 0;
				i = 0;
				{
					gboolean _tmp10_ = FALSE;
					_tmp10_ = TRUE;
					while (TRUE) {
						JsonArray* _tmp12_;
						TomlValue* _tmp13_ = NULL;
						JsonArray* _tmp14_;
						JsonNode* _tmp15_;
						TomlValue* _tmp16_;
						GeeArrayList* _tmp17_;
						if (!_tmp10_) {
							gint _tmp11_;
							_tmp11_ = i;
							i = _tmp11_ + 1;
						}
						_tmp10_ = FALSE;
						_tmp12_ = json_array;
						if (!(((guint) i) < json_array_get_length (_tmp12_))) {
							break;
						}
						_tmp14_ = json_array;
						_tmp15_ = json_array_get_element (_tmp14_, (guint) i);
						_tmp16_ = toml_value_from_json_node (_tmp15_, &_inner_error0_);
						_tmp13_ = _tmp16_;
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							if (_inner_error0_->domain == TOML_ERROR) {
								g_propagate_error (error, _inner_error0_);
								_json_array_unref0 (json_array);
								_g_object_unref0 (array);
								return NULL;
							} else {
								_json_array_unref0 (json_array);
								_g_object_unref0 (array);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
								g_clear_error (&_inner_error0_);
								return NULL;
							}
						}
						_tmp17_ = array;
						gee_abstract_collection_add ((GeeAbstractCollection*) _tmp17_, _tmp13_);
						_toml_value_unref0 (_tmp13_);
					}
				}
			}
			_tmp18_ = array;
			_tmp19_ = toml_value_new_array (_tmp18_);
			result = _tmp19_;
			_json_array_unref0 (json_array);
			_g_object_unref0 (array);
			return result;
		}
		case JSON_NODE_OBJECT:
		{
			GeeHashMap* table = NULL;
			GeeHashMap* _tmp20_;
			JsonObject* obj = NULL;
			JsonObject* _tmp21_;
			JsonObject* _tmp22_;
			JsonObject* _tmp23_;
			GList* _tmp24_;
			GeeHashMap* _tmp32_;
			TomlValue* _tmp33_;
			_tmp20_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			table = _tmp20_;
			_tmp21_ = json_node_get_object (node);
			_tmp22_ = _json_object_ref0 (_tmp21_);
			obj = _tmp22_;
			_tmp23_ = obj;
			_tmp24_ = json_object_get_members (_tmp23_);
			{
				GList* member_collection = NULL;
				GList* member_it = NULL;
				member_collection = _tmp24_;
				for (member_it = member_collection; member_it != NULL; member_it = member_it->next) {
					const gchar* member = NULL;
					member = (const gchar*) member_it->data;
					{
						TomlValue* _tmp25_ = NULL;
						JsonObject* _tmp26_;
						const gchar* _tmp27_;
						JsonNode* _tmp28_;
						TomlValue* _tmp29_;
						GeeHashMap* _tmp30_;
						const gchar* _tmp31_;
						_tmp26_ = obj;
						_tmp27_ = member;
						_tmp28_ = json_object_get_member (_tmp26_, _tmp27_);
						_tmp29_ = toml_value_from_json_node (_tmp28_, &_inner_error0_);
						_tmp25_ = _tmp29_;
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							if (_inner_error0_->domain == TOML_ERROR) {
								g_propagate_error (error, _inner_error0_);
								(member_collection == NULL) ? NULL : (member_collection = (g_list_free (member_collection), NULL));
								_json_object_unref0 (obj);
								_g_object_unref0 (table);
								return NULL;
							} else {
								(member_collection == NULL) ? NULL : (member_collection = (g_list_free (member_collection), NULL));
								_json_object_unref0 (obj);
								_g_object_unref0 (table);
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
								g_clear_error (&_inner_error0_);
								return NULL;
							}
						}
						_tmp30_ = table;
						_tmp31_ = member;
						gee_abstract_map_set ((GeeAbstractMap*) _tmp30_, _tmp31_, _tmp25_);
						_toml_value_unref0 (_tmp25_);
					}
				}
				(member_collection == NULL) ? NULL : (member_collection = (g_list_free (member_collection), NULL));
			}
			_tmp32_ = table;
			_tmp33_ = toml_value_new_table (_tmp32_);
			result = _tmp33_;
			_json_object_unref0 (obj);
			_g_object_unref0 (table);
			return result;
		}
		default:
		{
			GError* _tmp34_;
			_tmp34_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_VALUE, "Unsupported JSON node type");
			_inner_error0_ = _tmp34_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
	}
}

TomlValue*
toml_value_construct (GType object_type)
{
	TomlValue* self = NULL;
	self = (TomlValue*) g_type_create_instance (object_type);
	return self;
}

TomlValue*
toml_value_new (void)
{
	return toml_value_construct (TYPE_TOML_VALUE);
}

TomlType
toml_value_get_val_type (TomlValue* self)
{
	TomlType result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_val_type;
	return result;
}

static void
toml_value_set_val_type (TomlValue* self,
                         TomlType value)
{
	g_return_if_fail (self != NULL);
	self->priv->_val_type = value;
}

const gchar*
toml_value_get_string_val (TomlValue* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_string_val;
	result = _tmp0_;
	return result;
}

static void
toml_value_set_string_val (TomlValue* self,
                           const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_string_val);
	self->priv->_string_val = _tmp0_;
}

gint64
toml_value_get_int_val (TomlValue* self)
{
	gint64 result;
	g_return_val_if_fail (self != NULL, 0LL);
	result = self->priv->_int_val;
	return result;
}

static void
toml_value_set_int_val (TomlValue* self,
                        gint64 value)
{
	g_return_if_fail (self != NULL);
	self->priv->_int_val = value;
}

gdouble
toml_value_get_float_val (TomlValue* self)
{
	gdouble result;
	g_return_val_if_fail (self != NULL, 0.0);
	result = self->priv->_float_val;
	return result;
}

static void
toml_value_set_float_val (TomlValue* self,
                          gdouble value)
{
	g_return_if_fail (self != NULL);
	self->priv->_float_val = value;
}

gboolean
toml_value_get_bool_val (TomlValue* self)
{
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	result = self->priv->_bool_val;
	return result;
}

static void
toml_value_set_bool_val (TomlValue* self,
                         gboolean value)
{
	g_return_if_fail (self != NULL);
	self->priv->_bool_val = value;
}

GeeArrayList*
toml_value_get_array_val (TomlValue* self)
{
	GeeArrayList* result;
	GeeArrayList* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_array_val;
	result = _tmp0_;
	return result;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static void
toml_value_set_array_val (TomlValue* self,
                          GeeArrayList* value)
{
	GeeArrayList* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_array_val);
	self->priv->_array_val = _tmp0_;
}

GeeHashMap*
toml_value_get_table_val (TomlValue* self)
{
	GeeHashMap* result;
	GeeHashMap* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_table_val;
	result = _tmp0_;
	return result;
}

static void
toml_value_set_table_val (TomlValue* self,
                          GeeHashMap* value)
{
	GeeHashMap* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = _g_object_ref0 (value);
	_g_object_unref0 (self->priv->_table_val);
	self->priv->_table_val = _tmp0_;
}

static void
value_toml_value_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_toml_value_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		toml_value_unref (value->data[0].v_pointer);
	}
}

static void
value_toml_value_copy_value (const GValue* src_value,
                             GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = toml_value_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_toml_value_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_toml_value_collect_value (GValue* value,
                                guint n_collect_values,
                                GTypeCValue* collect_values,
                                guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		TomlValue * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = toml_value_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_toml_value_lcopy_value (const GValue* value,
                              guint n_collect_values,
                              GTypeCValue* collect_values,
                              guint collect_flags)
{
	TomlValue ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = toml_value_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_toml_value (const gchar* name,
                       const gchar* nick,
                       const gchar* blurb,
                       GType object_type,
                       GParamFlags flags)
{
	ParamSpecTomlValue* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TOML_VALUE), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_toml_value (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALUE), NULL);
	return value->data[0].v_pointer;
}

void
value_set_toml_value (GValue* value,
                      gpointer v_object)
{
	TomlValue * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALUE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALUE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		toml_value_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_value_unref (old);
	}
}

void
value_take_toml_value (GValue* value,
                       gpointer v_object)
{
	TomlValue * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALUE));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALUE));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_value_unref (old);
	}
}

static void
toml_value_class_init (TomlValueClass * klass,
                       gpointer klass_data)
{
	toml_value_parent_class = g_type_class_peek_parent (klass);
	((TomlValueClass *) klass)->finalize = toml_value_finalize;
	g_type_class_adjust_private_offset (klass, &TomlValue_private_offset);
}

static void
toml_value_instance_init (TomlValue * self,
                          gpointer klass)
{
	self->priv = toml_value_get_instance_private (self);
	self->ref_count = 1;
}

static void
toml_value_finalize (TomlValue * obj)
{
	TomlValue * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TOML_VALUE, TomlValue);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->_string_val);
	_g_object_unref0 (self->priv->_array_val);
	_g_object_unref0 (self->priv->_table_val);
}

static GType
toml_value_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_toml_value_init, value_toml_value_free_value, value_toml_value_copy_value, value_toml_value_peek_pointer, "p", value_toml_value_collect_value, "p", value_toml_value_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (TomlValueClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) toml_value_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TomlValue), 0, (GInstanceInitFunc) toml_value_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType toml_value_type_id;
	toml_value_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TomlValue", &g_define_type_info, &g_define_type_fundamental_info, 0);
	TomlValue_private_offset = g_type_add_instance_private (toml_value_type_id, sizeof (TomlValuePrivate));
	return toml_value_type_id;
}

GType
toml_value_get_type (void)
{
	static volatile gsize toml_value_type_id__once = 0;
	if (g_once_init_enter (&toml_value_type_id__once)) {
		GType toml_value_type_id;
		toml_value_type_id = toml_value_get_type_once ();
		g_once_init_leave (&toml_value_type_id__once, toml_value_type_id);
	}
	return toml_value_type_id__once;
}

gpointer
toml_value_ref (gpointer instance)
{
	TomlValue * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
toml_value_unref (gpointer instance)
{
	TomlValue * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		TOML_VALUE_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

GQuark
toml_error_quark (void)
{
	return g_quark_from_static_string ("toml-error-quark");
}

static GType
toml_error_get_type_once (void)
{
	static const GEnumValue values[] = {{TOML_ERROR_INVALID_SYNTAX, "TOML_ERROR_INVALID_SYNTAX", "invalid-syntax"}, {TOML_ERROR_INVALID_VALUE, "TOML_ERROR_INVALID_VALUE", "invalid-value"}, {TOML_ERROR_DUPLICATE_KEY, "TOML_ERROR_DUPLICATE_KEY", "duplicate-key"}, {TOML_ERROR_MISSING_KEY, "TOML_ERROR_MISSING_KEY", "missing-key"}, {0, NULL, NULL}};
	GType toml_error_type_id;
	toml_error_type_id = g_enum_register_static ("TomlError", values);
	return toml_error_type_id;
}

GType
toml_error_get_type (void)
{
	static volatile gsize toml_error_type_id__once = 0;
	if (g_once_init_enter (&toml_error_type_id__once)) {
		GType toml_error_type_id;
		toml_error_type_id = toml_error_get_type_once ();
		g_once_init_leave (&toml_error_type_id__once, toml_error_type_id);
	}
	return toml_error_type_id__once;
}

static inline gpointer
toml_parser_get_instance_private (TomlParser* self)
{
	return G_STRUCT_MEMBER_P (self, TomlParser_private_offset);
}

TomlParser*
toml_parser_construct (GType object_type,
                       const gchar* toml)
{
	TomlParser* self = NULL;
	gchar* _tmp0_;
	g_return_val_if_fail (toml != NULL, NULL);
	self = (TomlParser*) g_type_create_instance (object_type);
	_tmp0_ = g_strdup (toml);
	_g_free0 (self->priv->input);
	self->priv->input = _tmp0_;
	self->priv->pos = 0;
	self->priv->line = 1;
	self->priv->col = 1;
	return self;
}

TomlParser*
toml_parser_new (const gchar* toml)
{
	return toml_parser_construct (TYPE_TOML_PARSER, toml);
}

TomlValue*
toml_parser_parse_file (const gchar* filename,
                        const gchar* encoding,
                        GError** error)
{
	gchar* content = NULL;
	gchar* _tmp0_;
	TomlParser* parser = NULL;
	const gchar* _tmp1_;
	TomlParser* _tmp2_;
	TomlValue* _tmp3_ = NULL;
	TomlParser* _tmp4_;
	TomlValue* _tmp5_;
	TomlValue* _tmp6_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = toml_parser_read_file_content (filename, encoding, &_inner_error0_);
	content = _tmp0_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			return NULL;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
	}
	_tmp1_ = content;
	_tmp2_ = toml_parser_new (_tmp1_);
	parser = _tmp2_;
	_tmp4_ = parser;
	_tmp5_ = toml_parser_parse (_tmp4_, &_inner_error0_);
	_tmp3_ = _tmp5_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_toml_parser_unref0 (parser);
			_g_free0 (content);
			return NULL;
		} else {
			_toml_parser_unref0 (parser);
			_g_free0 (content);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
	}
	_tmp6_ = _tmp3_;
	_tmp3_ = NULL;
	result = _tmp6_;
	_toml_value_unref0 (_tmp3_);
	_toml_parser_unref0 (parser);
	_g_free0 (content);
	return result;
}

static void
toml_parser_parse_file_async_data_free (gpointer _data)
{
	TomlParserParseFileAsyncData* _data_;
	_data_ = _data;
	_g_free0 (_data_->filename);
	_g_free0 (_data_->encoding);
	_toml_value_unref0 (_data_->result);
	g_slice_free (TomlParserParseFileAsyncData, _data_);
}

void
toml_parser_parse_file_async (const gchar* filename,
                              const gchar* encoding,
                              GAsyncReadyCallback _callback_,
                              gpointer _user_data_)
{
	TomlParserParseFileAsyncData* _data_;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (filename != NULL);
	_data_ = g_slice_new0 (TomlParserParseFileAsyncData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, toml_parser_parse_file_async_data_free);
	_tmp0_ = g_strdup (filename);
	_g_free0 (_data_->filename);
	_data_->filename = _tmp0_;
	_tmp1_ = g_strdup (encoding);
	_g_free0 (_data_->encoding);
	_data_->encoding = _tmp1_;
	toml_parser_parse_file_async_co (_data_);
}

TomlValue*
toml_parser_parse_file_finish (GAsyncResult* _res_,
                               GError** error)
{
	TomlValue* result;
	TomlParserParseFileAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}

static void
toml_parser_parse_file_async_ready (GObject* source_object,
                                    GAsyncResult* _res_,
                                    gpointer _user_data_)
{
	TomlParserParseFileAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	toml_parser_parse_file_async_co (_data_);
}

static gboolean
toml_parser_parse_file_async_co (TomlParserParseFileAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	_data_->_state_ = 1;
	toml_parser_read_file_content_async (_data_->filename, _data_->encoding, toml_parser_parse_file_async_ready, _data_);
	return FALSE;
	_state_1:
	_data_->_tmp0_ = toml_parser_read_file_content_finish (_data_->_res_, &_data_->_inner_error0_);
	_data_->content = _data_->_tmp0_;
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		if (_data_->_inner_error0_->domain == TOML_ERROR) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp1_ = _data_->content;
	_data_->_tmp2_ = toml_parser_new (_data_->_tmp1_);
	_data_->parser = _data_->_tmp2_;
	_data_->_tmp4_ = _data_->parser;
	_data_->_tmp5_ = toml_parser_parse (_data_->_tmp4_, &_data_->_inner_error0_);
	_data_->_tmp3_ = _data_->_tmp5_;
	if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
		if (_data_->_inner_error0_->domain == TOML_ERROR) {
			g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
			_toml_parser_unref0 (_data_->parser);
			_g_free0 (_data_->content);
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_toml_parser_unref0 (_data_->parser);
			_g_free0 (_data_->content);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
			g_clear_error (&_data_->_inner_error0_);
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
	}
	_data_->_tmp6_ = _data_->_tmp3_;
	_data_->_tmp3_ = NULL;
	_data_->result = _data_->_tmp6_;
	_toml_value_unref0 (_data_->_tmp3_);
	_toml_parser_unref0 (_data_->parser);
	_g_free0 (_data_->content);
	g_task_return_pointer (_data_->_async_result, _data_, NULL);
	if (_data_->_state_ != 0) {
		while (!g_task_get_completed (_data_->_async_result)) {
			g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
		}
	}
	g_object_unref (_data_->_async_result);
	return FALSE;
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar _tmp0_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

static gchar
toml_parser_peek (TomlParser* self)
{
	const gchar* _tmp0_;
	gint _tmp1_;
	gint _tmp2_;
	const gchar* _tmp3_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = self->priv->input;
	_tmp1_ = strlen (_tmp0_);
	_tmp2_ = _tmp1_;
	if (self->priv->pos >= _tmp2_) {
		result = '\0';
		return result;
	}
	_tmp3_ = self->priv->input;
	result = string_get (_tmp3_, (glong) self->priv->pos);
	return result;
}

static gchar
toml_parser_next (TomlParser* self)
{
	gchar c = '\0';
	gint _tmp0_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	c = toml_parser_peek (self);
	_tmp0_ = self->priv->pos;
	self->priv->pos = _tmp0_ + 1;
	if (c == '\n') {
		gint _tmp1_;
		_tmp1_ = self->priv->line;
		self->priv->line = _tmp1_ + 1;
		self->priv->col = 1;
	} else {
		gint _tmp2_;
		_tmp2_ = self->priv->col;
		self->priv->col = _tmp2_ + 1;
	}
	result = c;
	return result;
}

static void
toml_parser_skip_whitespace (TomlParser* self)
{
	g_return_if_fail (self != NULL);
	while (TRUE) {
		gboolean _tmp0_ = FALSE;
		if (g_ascii_isspace (toml_parser_peek (self))) {
			_tmp0_ = toml_parser_peek (self) != '\n';
		} else {
			_tmp0_ = FALSE;
		}
		if (!_tmp0_) {
			break;
		}
		toml_parser_next (self);
	}
}

static void
toml_parser_skip_comment (TomlParser* self)
{
	g_return_if_fail (self != NULL);
	if (toml_parser_peek (self) == '#') {
		while (TRUE) {
			gboolean _tmp0_ = FALSE;
			if (toml_parser_next (self) != '\n') {
				_tmp0_ = toml_parser_peek (self) != '\0';
			} else {
				_tmp0_ = FALSE;
			}
			if (!_tmp0_) {
				break;
			}
		}
	}
}

static gchar*
toml_parser_parse_key (TomlParser* self,
                       GError** error)
{
	GString* key = NULL;
	GString* _tmp0_;
	GString* _tmp22_;
	const gchar* _tmp23_;
	gchar* _tmp24_;
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_skip_whitespace (self);
	_tmp0_ = g_string_new ("");
	key = _tmp0_;
	if (toml_parser_peek (self) == '"') {
		toml_parser_next (self);
		while (TRUE) {
			gboolean _tmp1_ = FALSE;
			if (toml_parser_peek (self) != '"') {
				_tmp1_ = toml_parser_peek (self) != '\0';
			} else {
				_tmp1_ = FALSE;
			}
			if (!_tmp1_) {
				break;
			}
			if (toml_parser_peek (self) == '\\') {
				toml_parser_next (self);
				if (toml_parser_peek (self) == '"') {
					GString* _tmp2_;
					_tmp2_ = key;
					g_string_append (_tmp2_, "\"");
				} else {
					if (toml_parser_peek (self) == '\\') {
						GString* _tmp3_;
						_tmp3_ = key;
						g_string_append (_tmp3_, "\\");
					} else {
						GError* _tmp4_;
						_tmp4_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Invalid escape in key");
						_inner_error0_ = _tmp4_;
						if (_inner_error0_->domain == TOML_ERROR) {
							g_propagate_error (error, _inner_error0_);
							_g_string_free0 (key);
							return NULL;
						} else {
							_g_string_free0 (key);
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return NULL;
						}
					}
				}
			} else {
				GString* _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				_tmp5_ = key;
				_tmp6_ = g_strdup_printf ("%c", toml_parser_next (self));
				_tmp7_ = _tmp6_;
				g_string_append (_tmp5_, _tmp7_);
				_g_free0 (_tmp7_);
			}
		}
		if (toml_parser_next (self) != '"') {
			GError* _tmp8_;
			_tmp8_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Unclosed string in key");
			_inner_error0_ = _tmp8_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_string_free0 (key);
				return NULL;
			} else {
				_g_string_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
	} else {
		if (toml_parser_peek (self) == '\'') {
			toml_parser_next (self);
			while (TRUE) {
				gboolean _tmp9_ = FALSE;
				GString* _tmp10_;
				gchar* _tmp11_;
				gchar* _tmp12_;
				if (toml_parser_peek (self) != '\'') {
					_tmp9_ = toml_parser_peek (self) != '\0';
				} else {
					_tmp9_ = FALSE;
				}
				if (!_tmp9_) {
					break;
				}
				_tmp10_ = key;
				_tmp11_ = g_strdup_printf ("%c", toml_parser_next (self));
				_tmp12_ = _tmp11_;
				g_string_append (_tmp10_, _tmp12_);
				_g_free0 (_tmp12_);
			}
			if (toml_parser_next (self) != '\'') {
				GError* _tmp13_;
				_tmp13_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Unclosed string in key");
				_inner_error0_ = _tmp13_;
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_g_string_free0 (key);
					return NULL;
				} else {
					_g_string_free0 (key);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		} else {
			while (TRUE) {
				gboolean _tmp14_ = FALSE;
				gboolean _tmp15_ = FALSE;
				gboolean _tmp16_ = FALSE;
				gboolean _tmp17_ = FALSE;
				gboolean _tmp18_ = FALSE;
				GString* _tmp19_;
				gchar* _tmp20_;
				gchar* _tmp21_;
				if (!g_ascii_isspace (toml_parser_peek (self))) {
					_tmp18_ = toml_parser_peek (self) != '=';
				} else {
					_tmp18_ = FALSE;
				}
				if (_tmp18_) {
					_tmp17_ = toml_parser_peek (self) != '.';
				} else {
					_tmp17_ = FALSE;
				}
				if (_tmp17_) {
					_tmp16_ = toml_parser_peek (self) != '[';
				} else {
					_tmp16_ = FALSE;
				}
				if (_tmp16_) {
					_tmp15_ = toml_parser_peek (self) != ']';
				} else {
					_tmp15_ = FALSE;
				}
				if (_tmp15_) {
					_tmp14_ = toml_parser_peek (self) != '\0';
				} else {
					_tmp14_ = FALSE;
				}
				if (!_tmp14_) {
					break;
				}
				_tmp19_ = key;
				_tmp20_ = g_strdup_printf ("%c", toml_parser_next (self));
				_tmp21_ = _tmp20_;
				g_string_append (_tmp19_, _tmp21_);
				_g_free0 (_tmp21_);
			}
		}
	}
	_tmp22_ = key;
	_tmp23_ = _tmp22_->str;
	_tmp24_ = g_strdup (_tmp23_);
	result = _tmp24_;
	_g_string_free0 (key);
	return result;
}

static TomlValue*
toml_parser_parse_value (TomlParser* self,
                         GError** error)
{
	gchar c = '\0';
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_skip_whitespace (self);
	c = toml_parser_peek (self);
	if (c == '"') {
		TomlValue* _tmp0_ = NULL;
		TomlValue* _tmp1_;
		TomlValue* _tmp2_;
		_tmp1_ = toml_parser_parse_string (self, &_inner_error0_);
		_tmp0_ = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp2_ = _tmp0_;
		_tmp0_ = NULL;
		result = _tmp2_;
		_toml_value_unref0 (_tmp0_);
		return result;
	} else {
		if (c == '\'') {
			TomlValue* _tmp3_ = NULL;
			TomlValue* _tmp4_;
			TomlValue* _tmp5_;
			_tmp4_ = toml_parser_parse_literal_string (self, &_inner_error0_);
			_tmp3_ = _tmp4_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					return NULL;
				} else {
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
			_tmp5_ = _tmp3_;
			_tmp3_ = NULL;
			result = _tmp5_;
			_toml_value_unref0 (_tmp3_);
			return result;
		} else {
			gboolean _tmp6_ = FALSE;
			gboolean _tmp7_ = FALSE;
			if (g_ascii_isdigit (c)) {
				_tmp7_ = TRUE;
			} else {
				_tmp7_ = c == '+';
			}
			if (_tmp7_) {
				_tmp6_ = TRUE;
			} else {
				_tmp6_ = c == '-';
			}
			if (_tmp6_) {
				TomlValue* _tmp8_ = NULL;
				TomlValue* _tmp9_;
				TomlValue* _tmp10_;
				_tmp9_ = toml_parser_parse_number (self, &_inner_error0_);
				_tmp8_ = _tmp9_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						return NULL;
					} else {
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_tmp10_ = _tmp8_;
				_tmp8_ = NULL;
				result = _tmp10_;
				_toml_value_unref0 (_tmp8_);
				return result;
			} else {
				gboolean _tmp11_ = FALSE;
				if (c == 't') {
					_tmp11_ = TRUE;
				} else {
					_tmp11_ = c == 'f';
				}
				if (_tmp11_) {
					TomlValue* _tmp12_ = NULL;
					TomlValue* _tmp13_;
					TomlValue* _tmp14_;
					_tmp13_ = toml_parser_parse_bool (self, &_inner_error0_);
					_tmp12_ = _tmp13_;
					if (G_UNLIKELY (_inner_error0_ != NULL)) {
						if (_inner_error0_->domain == TOML_ERROR) {
							g_propagate_error (error, _inner_error0_);
							return NULL;
						} else {
							g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
							g_clear_error (&_inner_error0_);
							return NULL;
						}
					}
					_tmp14_ = _tmp12_;
					_tmp12_ = NULL;
					result = _tmp14_;
					_toml_value_unref0 (_tmp12_);
					return result;
				} else {
					if (c == '[') {
						TomlValue* _tmp15_ = NULL;
						TomlValue* _tmp16_;
						TomlValue* _tmp17_;
						_tmp16_ = toml_parser_parse_array (self, &_inner_error0_);
						_tmp15_ = _tmp16_;
						if (G_UNLIKELY (_inner_error0_ != NULL)) {
							if (_inner_error0_->domain == TOML_ERROR) {
								g_propagate_error (error, _inner_error0_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
								g_clear_error (&_inner_error0_);
								return NULL;
							}
						}
						_tmp17_ = _tmp15_;
						_tmp15_ = NULL;
						result = _tmp17_;
						_toml_value_unref0 (_tmp15_);
						return result;
					} else {
						if (c == '{') {
							TomlValue* _tmp18_ = NULL;
							TomlValue* _tmp19_;
							TomlValue* _tmp20_;
							_tmp19_ = toml_parser_parse_inline_table (self, &_inner_error0_);
							_tmp18_ = _tmp19_;
							if (G_UNLIKELY (_inner_error0_ != NULL)) {
								if (_inner_error0_->domain == TOML_ERROR) {
									g_propagate_error (error, _inner_error0_);
									return NULL;
								} else {
									g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
									g_clear_error (&_inner_error0_);
									return NULL;
								}
							}
							_tmp20_ = _tmp18_;
							_tmp18_ = NULL;
							result = _tmp20_;
							_toml_value_unref0 (_tmp18_);
							return result;
						} else {
							GError* _tmp21_;
							_tmp21_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_VALUE, "Unknown value type");
							_inner_error0_ = _tmp21_;
							if (_inner_error0_->domain == TOML_ERROR) {
								g_propagate_error (error, _inner_error0_);
								return NULL;
							} else {
								g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
								g_clear_error (&_inner_error0_);
								return NULL;
							}
						}
					}
				}
			}
		}
	}
}

static TomlValue*
toml_parser_parse_string (TomlParser* self,
                          GError** error)
{
	GString* sb = NULL;
	GString* _tmp0_;
	gboolean multiline = FALSE;
	gboolean _tmp1_ = FALSE;
	GString* _tmp24_;
	const gchar* _tmp25_;
	TomlValue* _tmp26_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	toml_parser_next (self);
	multiline = FALSE;
	if (toml_parser_peek (self) == '"') {
		const gchar* _tmp2_;
		_tmp2_ = self->priv->input;
		_tmp1_ = string_get (_tmp2_, (glong) (self->priv->pos + 1)) == '"';
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		multiline = TRUE;
		toml_parser_next (self);
		toml_parser_next (self);
	}
	while (TRUE) {
		gchar c = '\0';
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		c = toml_parser_next (self);
		if (c == '\0') {
			GError* _tmp3_;
			_tmp3_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Unclosed string");
			_inner_error0_ = _tmp3_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_string_free0 (sb);
				return NULL;
			} else {
				_g_string_free0 (sb);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		if (multiline) {
			_tmp6_ = c == '"';
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			_tmp5_ = toml_parser_peek (self) == '"';
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			const gchar* _tmp7_;
			_tmp7_ = self->priv->input;
			_tmp4_ = string_get (_tmp7_, (glong) (self->priv->pos + 1)) == '"';
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			toml_parser_next (self);
			toml_parser_next (self);
			toml_parser_next (self);
			break;
		} else {
			gboolean _tmp8_ = FALSE;
			if (!multiline) {
				_tmp8_ = c == '"';
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				break;
			} else {
				if (c == '\\') {
					c = toml_parser_next (self);
					if (c == 'n') {
						GString* _tmp9_;
						_tmp9_ = sb;
						g_string_append (_tmp9_, "\n");
					} else {
						if (c == 't') {
							GString* _tmp10_;
							_tmp10_ = sb;
							g_string_append (_tmp10_, "\t");
						} else {
							if (c == 'r') {
								GString* _tmp11_;
								_tmp11_ = sb;
								g_string_append (_tmp11_, "\r");
							} else {
								if (c == '"') {
									GString* _tmp12_;
									_tmp12_ = sb;
									g_string_append (_tmp12_, "\"");
								} else {
									if (c == '\\') {
										GString* _tmp13_;
										_tmp13_ = sb;
										g_string_append (_tmp13_, "\\");
									} else {
										gboolean _tmp14_ = FALSE;
										if (c == 'u') {
											_tmp14_ = TRUE;
										} else {
											_tmp14_ = c == 'U';
										}
										if (_tmp14_) {
											GString* _tmp15_;
											gchar* _tmp16_;
											gchar* _tmp17_;
											gchar* _tmp18_;
											gchar* _tmp19_;
											_tmp15_ = sb;
											_tmp16_ = g_strdup_printf ("%c", c);
											_tmp17_ = _tmp16_;
											_tmp18_ = g_strconcat ("\\", _tmp17_, NULL);
											_tmp19_ = _tmp18_;
											g_string_append (_tmp15_, _tmp19_);
											_g_free0 (_tmp19_);
											_g_free0 (_tmp17_);
										} else {
											GError* _tmp20_;
											_tmp20_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Invalid escape");
											_inner_error0_ = _tmp20_;
											if (_inner_error0_->domain == TOML_ERROR) {
												g_propagate_error (error, _inner_error0_);
												_g_string_free0 (sb);
												return NULL;
											} else {
												_g_string_free0 (sb);
												g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
												g_clear_error (&_inner_error0_);
												return NULL;
											}
										}
									}
								}
							}
						}
					}
				} else {
					GString* _tmp21_;
					gchar* _tmp22_;
					gchar* _tmp23_;
					_tmp21_ = sb;
					_tmp22_ = g_strdup_printf ("%c", c);
					_tmp23_ = _tmp22_;
					g_string_append (_tmp21_, _tmp23_);
					_g_free0 (_tmp23_);
				}
			}
		}
	}
	_tmp24_ = sb;
	_tmp25_ = _tmp24_->str;
	_tmp26_ = toml_value_new_string (_tmp25_);
	result = _tmp26_;
	_g_string_free0 (sb);
	return result;
}

static TomlValue*
toml_parser_parse_literal_string (TomlParser* self,
                                  GError** error)
{
	GString* sb = NULL;
	GString* _tmp0_;
	gboolean multiline = FALSE;
	gboolean _tmp1_ = FALSE;
	GString* _tmp12_;
	const gchar* _tmp13_;
	TomlValue* _tmp14_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	toml_parser_next (self);
	multiline = FALSE;
	if (toml_parser_peek (self) == '\'') {
		const gchar* _tmp2_;
		_tmp2_ = self->priv->input;
		_tmp1_ = string_get (_tmp2_, (glong) (self->priv->pos + 1)) == '\'';
	} else {
		_tmp1_ = FALSE;
	}
	if (_tmp1_) {
		multiline = TRUE;
		toml_parser_next (self);
		toml_parser_next (self);
	}
	while (TRUE) {
		gchar c = '\0';
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gboolean _tmp6_ = FALSE;
		c = toml_parser_next (self);
		if (c == '\0') {
			GError* _tmp3_;
			_tmp3_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Unclosed literal string");
			_inner_error0_ = _tmp3_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_string_free0 (sb);
				return NULL;
			} else {
				_g_string_free0 (sb);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		if (multiline) {
			_tmp6_ = c == '\'';
		} else {
			_tmp6_ = FALSE;
		}
		if (_tmp6_) {
			_tmp5_ = toml_parser_peek (self) == '\'';
		} else {
			_tmp5_ = FALSE;
		}
		if (_tmp5_) {
			const gchar* _tmp7_;
			_tmp7_ = self->priv->input;
			_tmp4_ = string_get (_tmp7_, (glong) (self->priv->pos + 1)) == '\'';
		} else {
			_tmp4_ = FALSE;
		}
		if (_tmp4_) {
			toml_parser_next (self);
			toml_parser_next (self);
			toml_parser_next (self);
			break;
		} else {
			gboolean _tmp8_ = FALSE;
			if (!multiline) {
				_tmp8_ = c == '\'';
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				break;
			} else {
				GString* _tmp9_;
				gchar* _tmp10_;
				gchar* _tmp11_;
				_tmp9_ = sb;
				_tmp10_ = g_strdup_printf ("%c", c);
				_tmp11_ = _tmp10_;
				g_string_append (_tmp9_, _tmp11_);
				_g_free0 (_tmp11_);
			}
		}
	}
	_tmp12_ = sb;
	_tmp13_ = _tmp12_->str;
	_tmp14_ = toml_value_new_string (_tmp13_);
	result = _tmp14_;
	_g_string_free0 (sb);
	return result;
}

static gdouble
double_parse (const gchar* str)
{
	gdouble result;
	g_return_val_if_fail (str != NULL, 0.0);
	result = g_ascii_strtod (str, NULL);
	return result;
}

static gint64
int64_parse (const gchar* str,
             guint _base)
{
	gint64 result;
	g_return_val_if_fail (str != NULL, 0LL);
	result = g_ascii_strtoll (str, NULL, _base);
	return result;
}

static TomlValue*
toml_parser_parse_number (TomlParser* self,
                          GError** error)
{
	GString* sb = NULL;
	GString* _tmp0_;
	gboolean is_float = FALSE;
	gchar* num_str = NULL;
	GString* _tmp11_;
	const gchar* _tmp12_;
	gchar* _tmp13_;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_string_new ("");
	sb = _tmp0_;
	is_float = FALSE;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		gboolean _tmp3_ = FALSE;
		gboolean _tmp4_ = FALSE;
		gboolean _tmp5_ = FALSE;
		gchar c = '\0';
		GString* _tmp6_;
		gchar* _tmp7_;
		gchar* _tmp8_;
		gboolean _tmp9_ = FALSE;
		gboolean _tmp10_ = FALSE;
		if (g_ascii_isdigit (toml_parser_peek (self))) {
			_tmp5_ = TRUE;
		} else {
			_tmp5_ = toml_parser_peek (self) == '+';
		}
		if (_tmp5_) {
			_tmp4_ = TRUE;
		} else {
			_tmp4_ = toml_parser_peek (self) == '-';
		}
		if (_tmp4_) {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = toml_parser_peek (self) == '.';
		}
		if (_tmp3_) {
			_tmp2_ = TRUE;
		} else {
			_tmp2_ = toml_parser_peek (self) == 'e';
		}
		if (_tmp2_) {
			_tmp1_ = TRUE;
		} else {
			_tmp1_ = toml_parser_peek (self) == 'E';
		}
		if (!_tmp1_) {
			break;
		}
		c = toml_parser_next (self);
		_tmp6_ = sb;
		_tmp7_ = g_strdup_printf ("%c", c);
		_tmp8_ = _tmp7_;
		g_string_append (_tmp6_, _tmp8_);
		_g_free0 (_tmp8_);
		if (c == '.') {
			_tmp10_ = TRUE;
		} else {
			_tmp10_ = c == 'e';
		}
		if (_tmp10_) {
			_tmp9_ = TRUE;
		} else {
			_tmp9_ = c == 'E';
		}
		if (_tmp9_) {
			is_float = TRUE;
		}
	}
	_tmp11_ = sb;
	_tmp12_ = _tmp11_->str;
	_tmp13_ = g_strdup (_tmp12_);
	num_str = _tmp13_;
	if (is_float) {
		gdouble val = 0.0;
		const gchar* _tmp14_;
		TomlValue* _tmp15_;
		_tmp14_ = num_str;
		val = double_parse (_tmp14_);
		_tmp15_ = toml_value_new_float (val);
		result = _tmp15_;
		_g_free0 (num_str);
		_g_string_free0 (sb);
		return result;
	} else {
		gint64 val = 0LL;
		const gchar* _tmp16_;
		TomlValue* _tmp17_;
		_tmp16_ = num_str;
		val = int64_parse (_tmp16_, (guint) 0);
		_tmp17_ = toml_value_new_int (val);
		result = _tmp17_;
		_g_free0 (num_str);
		_g_string_free0 (sb);
		return result;
	}
}

static glong
string_strnlen (gchar* str,
                glong maxlen)
{
	gchar* end = NULL;
	gchar* _tmp0_;
	gchar* _tmp1_;
	glong result;
	_tmp0_ = memchr (str, 0, (gsize) maxlen);
	end = _tmp0_;
	_tmp1_ = end;
	if (_tmp1_ == NULL) {
		result = maxlen;
		return result;
	} else {
		gchar* _tmp2_;
		_tmp2_ = end;
		result = (glong) (_tmp2_ - str);
		return result;
	}
}

static gchar*
string_substring (const gchar* self,
                  glong offset,
                  glong len)
{
	glong string_length = 0L;
	gboolean _tmp0_ = FALSE;
	gchar* _tmp3_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	if (offset >= ((glong) 0)) {
		_tmp0_ = len >= ((glong) 0);
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		string_length = string_strnlen ((gchar*) self, offset + len);
	} else {
		gint _tmp1_;
		gint _tmp2_;
		_tmp1_ = strlen (self);
		_tmp2_ = _tmp1_;
		string_length = (glong) _tmp2_;
	}
	if (offset < ((glong) 0)) {
		offset = string_length + offset;
		g_return_val_if_fail (offset >= ((glong) 0), NULL);
	} else {
		g_return_val_if_fail (offset <= string_length, NULL);
	}
	if (len < ((glong) 0)) {
		len = string_length - offset;
	}
	g_return_val_if_fail ((offset + len) <= string_length, NULL);
	_tmp3_ = g_strndup (((gchar*) self) + offset, (gsize) len);
	result = _tmp3_;
	return result;
}

static TomlValue*
toml_parser_parse_bool (TomlParser* self,
                        GError** error)
{
	const gchar* _tmp0_;
	gchar* _tmp1_;
	gchar* _tmp2_;
	gboolean _tmp3_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->input;
	_tmp1_ = string_substring (_tmp0_, (glong) self->priv->pos, (glong) 4);
	_tmp2_ = _tmp1_;
	_tmp3_ = g_strcmp0 (_tmp2_, "true") == 0;
	_g_free0 (_tmp2_);
	if (_tmp3_) {
		TomlValue* _tmp4_;
		self->priv->pos = self->priv->pos + 4;
		_tmp4_ = toml_value_new_bool (TRUE);
		result = _tmp4_;
		return result;
	} else {
		const gchar* _tmp5_;
		gchar* _tmp6_;
		gchar* _tmp7_;
		gboolean _tmp8_;
		_tmp5_ = self->priv->input;
		_tmp6_ = string_substring (_tmp5_, (glong) self->priv->pos, (glong) 5);
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strcmp0 (_tmp7_, "false") == 0;
		_g_free0 (_tmp7_);
		if (_tmp8_) {
			TomlValue* _tmp9_;
			self->priv->pos = self->priv->pos + 5;
			_tmp9_ = toml_value_new_bool (FALSE);
			result = _tmp9_;
			return result;
		} else {
			GError* _tmp10_;
			_tmp10_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_VALUE, "Invalid boolean");
			_inner_error0_ = _tmp10_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return NULL;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
	}
}

static TomlValue*
toml_parser_parse_array (TomlParser* self,
                         GError** error)
{
	GeeArrayList* array = NULL;
	GeeArrayList* _tmp0_;
	GeeArrayList* _tmp5_;
	TomlValue* _tmp6_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_next (self);
	_tmp0_ = gee_array_list_new (TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL);
	array = _tmp0_;
	while (TRUE) {
		TomlValue* val = NULL;
		TomlValue* _tmp1_;
		GeeArrayList* _tmp2_;
		TomlValue* _tmp3_;
		if (!(toml_parser_peek (self) != ']')) {
			break;
		}
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == ']') {
			break;
		}
		_tmp1_ = toml_parser_parse_value (self, &_inner_error0_);
		val = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (array);
				return NULL;
			} else {
				_g_object_unref0 (array);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp2_ = array;
		_tmp3_ = val;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, _tmp3_);
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == ',') {
			toml_parser_next (self);
		} else {
			if (toml_parser_peek (self) != ']') {
				GError* _tmp4_;
				_tmp4_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected , or ] in array");
				_inner_error0_ = _tmp4_;
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_toml_value_unref0 (val);
					_g_object_unref0 (array);
					return NULL;
				} else {
					_toml_value_unref0 (val);
					_g_object_unref0 (array);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		}
		_toml_value_unref0 (val);
	}
	toml_parser_next (self);
	_tmp5_ = array;
	_tmp6_ = toml_value_new_array (_tmp5_);
	result = _tmp6_;
	_g_object_unref0 (array);
	return result;
}

static TomlValue*
toml_parser_parse_inline_table (TomlParser* self,
                                GError** error)
{
	GeeHashMap* table = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp8_;
	TomlValue* _tmp9_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_next (self);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	table = _tmp0_;
	while (TRUE) {
		gchar* key = NULL;
		gchar* _tmp1_;
		TomlValue* val = NULL;
		TomlValue* _tmp3_;
		GeeHashMap* _tmp4_;
		const gchar* _tmp5_;
		TomlValue* _tmp6_;
		if (!(toml_parser_peek (self) != '}')) {
			break;
		}
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == '}') {
			break;
		}
		_tmp1_ = toml_parser_parse_key (self, &_inner_error0_);
		key = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (table);
				return NULL;
			} else {
				_g_object_unref0 (table);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		toml_parser_skip_whitespace (self);
		if (toml_parser_next (self) != '=') {
			GError* _tmp2_;
			_tmp2_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected = in inline table");
			_inner_error0_ = _tmp2_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_free0 (key);
				_g_object_unref0 (table);
				return NULL;
			} else {
				_g_free0 (key);
				_g_object_unref0 (table);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp3_ = toml_parser_parse_value (self, &_inner_error0_);
		val = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_free0 (key);
				_g_object_unref0 (table);
				return NULL;
			} else {
				_g_free0 (key);
				_g_object_unref0 (table);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp4_ = table;
		_tmp5_ = key;
		_tmp6_ = val;
		gee_abstract_map_set ((GeeAbstractMap*) _tmp4_, _tmp5_, _tmp6_);
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == ',') {
			toml_parser_next (self);
		} else {
			if (toml_parser_peek (self) != '}') {
				GError* _tmp7_;
				_tmp7_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected , or } in inline table");
				_inner_error0_ = _tmp7_;
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_toml_value_unref0 (val);
					_g_free0 (key);
					_g_object_unref0 (table);
					return NULL;
				} else {
					_toml_value_unref0 (val);
					_g_free0 (key);
					_g_object_unref0 (table);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		}
		_toml_value_unref0 (val);
		_g_free0 (key);
	}
	toml_parser_next (self);
	_tmp8_ = table;
	_tmp9_ = toml_value_new_table (_tmp8_);
	result = _tmp9_;
	_g_object_unref0 (table);
	return result;
}

static GeeArrayList*
toml_parser_parse_table_header (TomlParser* self,
                                GError** error)
{
	GeeArrayList* keys = NULL;
	GeeArrayList* _tmp0_;
	GError* _inner_error0_ = NULL;
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_next (self);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	keys = _tmp0_;
	while (TRUE) {
		gchar* key = NULL;
		gchar* _tmp1_;
		GeeArrayList* _tmp2_;
		const gchar* _tmp3_;
		if (!(toml_parser_peek (self) != ']')) {
			break;
		}
		toml_parser_skip_whitespace (self);
		_tmp1_ = toml_parser_parse_key (self, &_inner_error0_);
		key = _tmp1_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (keys);
				return NULL;
			} else {
				_g_object_unref0 (keys);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp2_ = keys;
		_tmp3_ = key;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp2_, _tmp3_);
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == '.') {
			toml_parser_next (self);
		} else {
			if (toml_parser_peek (self) != ']') {
				GError* _tmp4_;
				_tmp4_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected . or ] in table header");
				_inner_error0_ = _tmp4_;
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_g_free0 (key);
					_g_object_unref0 (keys);
					return NULL;
				} else {
					_g_free0 (key);
					_g_object_unref0 (keys);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		}
		_g_free0 (key);
	}
	toml_parser_next (self);
	result = keys;
	return result;
}

static GeeArrayList*
toml_parser_parse_array_table_header (TomlParser* self,
                                      GError** error)
{
	GeeArrayList* keys = NULL;
	GeeArrayList* _tmp0_;
	GError* _inner_error0_ = NULL;
	GeeArrayList* result;
	g_return_val_if_fail (self != NULL, NULL);
	toml_parser_next (self);
	toml_parser_next (self);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	keys = _tmp0_;
	while (TRUE) {
		gboolean _tmp1_ = FALSE;
		gchar* key = NULL;
		gchar* _tmp3_;
		GeeArrayList* _tmp4_;
		const gchar* _tmp5_;
		if (toml_parser_peek (self) != ']') {
			_tmp1_ = TRUE;
		} else {
			const gchar* _tmp2_;
			_tmp2_ = self->priv->input;
			_tmp1_ = string_get (_tmp2_, (glong) (self->priv->pos + 1)) != ']';
		}
		if (!_tmp1_) {
			break;
		}
		toml_parser_skip_whitespace (self);
		_tmp3_ = toml_parser_parse_key (self, &_inner_error0_);
		key = _tmp3_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (keys);
				return NULL;
			} else {
				_g_object_unref0 (keys);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return NULL;
			}
		}
		_tmp4_ = keys;
		_tmp5_ = key;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp4_, _tmp5_);
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == '.') {
			toml_parser_next (self);
		} else {
			gboolean _tmp6_ = FALSE;
			if (toml_parser_peek (self) != ']') {
				_tmp6_ = TRUE;
			} else {
				const gchar* _tmp7_;
				_tmp7_ = self->priv->input;
				_tmp6_ = string_get (_tmp7_, (glong) (self->priv->pos + 1)) != ']';
			}
			if (_tmp6_) {
				GError* _tmp8_;
				_tmp8_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected . or ]] in array table header");
				_inner_error0_ = _tmp8_;
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_g_free0 (key);
					_g_object_unref0 (keys);
					return NULL;
				} else {
					_g_free0 (key);
					_g_object_unref0 (keys);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		}
		_g_free0 (key);
	}
	toml_parser_next (self);
	toml_parser_next (self);
	result = keys;
	return result;
}

static void
toml_parser_set_nested_value (TomlParser* self,
                              GeeHashMap* root,
                              GeeArrayList* keys,
                              TomlValue* val,
                              gint start,
                              GError** error)
{
	gint _tmp0_;
	gint _tmp1_;
	gchar* key = NULL;
	gpointer _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (root != NULL);
	g_return_if_fail (keys != NULL);
	g_return_if_fail (val != NULL);
	_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) keys);
	_tmp1_ = _tmp0_;
	if (start >= _tmp1_) {
		return;
	}
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) keys, start);
	key = (gchar*) _tmp2_;
	_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) keys);
	_tmp4_ = _tmp3_;
	if (start == (_tmp4_ - 1)) {
		const gchar* _tmp5_;
		const gchar* _tmp11_;
		_tmp5_ = key;
		if (gee_abstract_map_has_key ((GeeAbstractMap*) root, _tmp5_)) {
			const gchar* _tmp6_;
			gchar* _tmp7_;
			gchar* _tmp8_;
			GError* _tmp9_;
			GError* _tmp10_;
			_tmp6_ = key;
			_tmp7_ = g_strconcat ("Duplicate key: ", _tmp6_, NULL);
			_tmp8_ = _tmp7_;
			_tmp9_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_DUPLICATE_KEY, _tmp8_);
			_tmp10_ = _tmp9_;
			_g_free0 (_tmp8_);
			_inner_error0_ = _tmp10_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_free0 (key);
				return;
			} else {
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_tmp11_ = key;
		gee_abstract_map_set ((GeeAbstractMap*) root, _tmp11_, val);
	} else {
		const gchar* _tmp12_;
		TomlValue* sub = NULL;
		const gchar* _tmp18_;
		gpointer _tmp19_;
		TomlValue* _tmp20_;
		TomlType _tmp21_;
		TomlType _tmp22_;
		TomlValue* _tmp24_;
		GeeHashMap* _tmp25_;
		GeeHashMap* _tmp26_;
		_tmp12_ = key;
		if (!gee_abstract_map_has_key ((GeeAbstractMap*) root, _tmp12_)) {
			const gchar* _tmp13_;
			GeeHashMap* _tmp14_;
			GeeHashMap* _tmp15_;
			TomlValue* _tmp16_;
			TomlValue* _tmp17_;
			_tmp13_ = key;
			_tmp14_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			_tmp15_ = _tmp14_;
			_tmp16_ = toml_value_new_table (_tmp15_);
			_tmp17_ = _tmp16_;
			gee_abstract_map_set ((GeeAbstractMap*) root, _tmp13_, _tmp17_);
			_toml_value_unref0 (_tmp17_);
			_g_object_unref0 (_tmp15_);
		}
		_tmp18_ = key;
		_tmp19_ = gee_abstract_map_get ((GeeAbstractMap*) root, _tmp18_);
		sub = (TomlValue*) _tmp19_;
		_tmp20_ = sub;
		_tmp21_ = toml_value_get_val_type (_tmp20_);
		_tmp22_ = _tmp21_;
		if (_tmp22_ != TOML_TYPE_TABLE) {
			GError* _tmp23_;
			_tmp23_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Key conflict");
			_inner_error0_ = _tmp23_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_toml_value_unref0 (sub);
				_g_free0 (key);
				return;
			} else {
				_toml_value_unref0 (sub);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_tmp24_ = sub;
		_tmp25_ = toml_value_get_table_val (_tmp24_);
		_tmp26_ = _tmp25_;
		toml_parser_set_nested_value (self, _tmp26_, keys, val, start + 1, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_toml_value_unref0 (sub);
				_g_free0 (key);
				return;
			} else {
				_toml_value_unref0 (sub);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_toml_value_unref0 (sub);
	}
	_g_free0 (key);
}

static void
toml_parser_add_to_array_table (TomlParser* self,
                                GeeHashMap* root,
                                GeeArrayList* keys,
                                GeeHashMap* table,
                                GError** error)
{
	gint _tmp0_;
	gint _tmp1_;
	gchar* key = NULL;
	gpointer _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (root != NULL);
	g_return_if_fail (keys != NULL);
	g_return_if_fail (table != NULL);
	_tmp0_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) keys);
	_tmp1_ = _tmp0_;
	if (_tmp1_ == 0) {
		return;
	}
	_tmp2_ = gee_abstract_list_get ((GeeAbstractList*) keys, 0);
	key = (gchar*) _tmp2_;
	_tmp3_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) keys);
	_tmp4_ = _tmp3_;
	if (_tmp4_ == 1) {
		const gchar* _tmp5_;
		TomlValue* arr_val = NULL;
		const gchar* _tmp11_;
		gpointer _tmp12_;
		TomlValue* _tmp13_;
		TomlType _tmp14_;
		TomlType _tmp15_;
		TomlValue* _tmp17_;
		GeeArrayList* _tmp18_;
		GeeArrayList* _tmp19_;
		TomlValue* _tmp20_;
		TomlValue* _tmp21_;
		_tmp5_ = key;
		if (!gee_abstract_map_has_key ((GeeAbstractMap*) root, _tmp5_)) {
			const gchar* _tmp6_;
			GeeArrayList* _tmp7_;
			GeeArrayList* _tmp8_;
			TomlValue* _tmp9_;
			TomlValue* _tmp10_;
			_tmp6_ = key;
			_tmp7_ = gee_array_list_new (TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL);
			_tmp8_ = _tmp7_;
			_tmp9_ = toml_value_new_array (_tmp8_);
			_tmp10_ = _tmp9_;
			gee_abstract_map_set ((GeeAbstractMap*) root, _tmp6_, _tmp10_);
			_toml_value_unref0 (_tmp10_);
			_g_object_unref0 (_tmp8_);
		}
		_tmp11_ = key;
		_tmp12_ = gee_abstract_map_get ((GeeAbstractMap*) root, _tmp11_);
		arr_val = (TomlValue*) _tmp12_;
		_tmp13_ = arr_val;
		_tmp14_ = toml_value_get_val_type (_tmp13_);
		_tmp15_ = _tmp14_;
		if (_tmp15_ != TOML_TYPE_ARRAY) {
			GError* _tmp16_;
			_tmp16_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Key conflict");
			_inner_error0_ = _tmp16_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_toml_value_unref0 (arr_val);
				_g_free0 (key);
				return;
			} else {
				_toml_value_unref0 (arr_val);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_tmp17_ = arr_val;
		_tmp18_ = toml_value_get_array_val (_tmp17_);
		_tmp19_ = _tmp18_;
		_tmp20_ = toml_value_new_table (table);
		_tmp21_ = _tmp20_;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp19_, _tmp21_);
		_toml_value_unref0 (_tmp21_);
		_toml_value_unref0 (arr_val);
	} else {
		const gchar* _tmp22_;
		TomlValue* sub = NULL;
		const gchar* _tmp28_;
		gpointer _tmp29_;
		TomlValue* _tmp30_;
		TomlType _tmp31_;
		TomlType _tmp32_;
		GeeArrayList* sub_keys = NULL;
		GeeArrayList* _tmp34_;
		TomlValue* _tmp42_;
		GeeHashMap* _tmp43_;
		GeeHashMap* _tmp44_;
		GeeArrayList* _tmp45_;
		_tmp22_ = key;
		if (!gee_abstract_map_has_key ((GeeAbstractMap*) root, _tmp22_)) {
			const gchar* _tmp23_;
			GeeHashMap* _tmp24_;
			GeeHashMap* _tmp25_;
			TomlValue* _tmp26_;
			TomlValue* _tmp27_;
			_tmp23_ = key;
			_tmp24_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
			_tmp25_ = _tmp24_;
			_tmp26_ = toml_value_new_table (_tmp25_);
			_tmp27_ = _tmp26_;
			gee_abstract_map_set ((GeeAbstractMap*) root, _tmp23_, _tmp27_);
			_toml_value_unref0 (_tmp27_);
			_g_object_unref0 (_tmp25_);
		}
		_tmp28_ = key;
		_tmp29_ = gee_abstract_map_get ((GeeAbstractMap*) root, _tmp28_);
		sub = (TomlValue*) _tmp29_;
		_tmp30_ = sub;
		_tmp31_ = toml_value_get_val_type (_tmp30_);
		_tmp32_ = _tmp31_;
		if (_tmp32_ != TOML_TYPE_TABLE) {
			GError* _tmp33_;
			_tmp33_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Key conflict");
			_inner_error0_ = _tmp33_;
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_toml_value_unref0 (sub);
				_g_free0 (key);
				return;
			} else {
				_toml_value_unref0 (sub);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_tmp34_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
		sub_keys = _tmp34_;
		{
			gint i = 0;
			i = 1;
			{
				gboolean _tmp35_ = FALSE;
				_tmp35_ = TRUE;
				while (TRUE) {
					gint _tmp37_;
					gint _tmp38_;
					GeeArrayList* _tmp39_;
					gpointer _tmp40_;
					gchar* _tmp41_;
					if (!_tmp35_) {
						gint _tmp36_;
						_tmp36_ = i;
						i = _tmp36_ + 1;
					}
					_tmp35_ = FALSE;
					_tmp37_ = gee_abstract_collection_get_size ((GeeAbstractCollection*) keys);
					_tmp38_ = _tmp37_;
					if (!(i < _tmp38_)) {
						break;
					}
					_tmp39_ = sub_keys;
					_tmp40_ = gee_abstract_list_get ((GeeAbstractList*) keys, i);
					_tmp41_ = (gchar*) _tmp40_;
					gee_abstract_collection_add ((GeeAbstractCollection*) _tmp39_, _tmp41_);
					_g_free0 (_tmp41_);
				}
			}
		}
		_tmp42_ = sub;
		_tmp43_ = toml_value_get_table_val (_tmp42_);
		_tmp44_ = _tmp43_;
		_tmp45_ = sub_keys;
		toml_parser_add_to_array_table (self, _tmp44_, _tmp45_, table, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_object_unref0 (sub_keys);
				_toml_value_unref0 (sub);
				_g_free0 (key);
				return;
			} else {
				_g_object_unref0 (sub_keys);
				_toml_value_unref0 (sub);
				_g_free0 (key);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_g_object_unref0 (sub_keys);
		_toml_value_unref0 (sub);
	}
	_g_free0 (key);
}

TomlValue*
toml_parser_parse (TomlParser* self,
                   GError** error)
{
	GeeHashMap* root = NULL;
	GeeHashMap* _tmp0_;
	GeeHashMap* _tmp20_;
	TomlValue* _tmp21_;
	GError* _inner_error0_ = NULL;
	TomlValue* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
	root = _tmp0_;
	while (TRUE) {
		const gchar* _tmp1_;
		gint _tmp2_;
		gint _tmp3_;
		_tmp1_ = self->priv->input;
		_tmp2_ = strlen (_tmp1_);
		_tmp3_ = _tmp2_;
		if (!(self->priv->pos < _tmp3_)) {
			break;
		}
		toml_parser_skip_whitespace (self);
		toml_parser_skip_comment (self);
		if (toml_parser_peek (self) == '\0') {
			break;
		}
		if (toml_parser_peek (self) == '[') {
			const gchar* _tmp4_;
			_tmp4_ = self->priv->input;
			if (string_get (_tmp4_, (glong) (self->priv->pos + 1)) == '[') {
				GeeArrayList* keys = NULL;
				GeeArrayList* _tmp5_;
				GeeHashMap* table = NULL;
				GeeHashMap* _tmp6_;
				GeeHashMap* _tmp7_;
				GeeHashMap* _tmp8_;
				GeeArrayList* _tmp9_;
				GeeHashMap* _tmp10_;
				_tmp5_ = toml_parser_parse_array_table_header (self, &_inner_error0_);
				keys = _tmp5_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_tmp6_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
				table = _tmp6_;
				_tmp7_ = table;
				toml_parser_parse_table_content (self, _tmp7_, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_tmp8_ = root;
				_tmp9_ = keys;
				_tmp10_ = table;
				toml_parser_add_to_array_table (self, _tmp8_, _tmp9_, _tmp10_, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_g_object_unref0 (table);
				_g_object_unref0 (keys);
			} else {
				GeeArrayList* keys = NULL;
				GeeArrayList* _tmp11_;
				GeeHashMap* table = NULL;
				GeeHashMap* _tmp12_;
				GeeHashMap* _tmp13_;
				GeeHashMap* _tmp14_;
				GeeArrayList* _tmp15_;
				GeeHashMap* _tmp16_;
				TomlValue* _tmp17_;
				TomlValue* _tmp18_;
				_tmp11_ = toml_parser_parse_table_header (self, &_inner_error0_);
				keys = _tmp11_;
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_tmp12_ = gee_hash_map_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, TYPE_TOML_VALUE, (GBoxedCopyFunc) toml_value_ref, (GDestroyNotify) toml_value_unref, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
				table = _tmp12_;
				_tmp13_ = table;
				toml_parser_parse_table_content (self, _tmp13_, &_inner_error0_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_tmp14_ = root;
				_tmp15_ = keys;
				_tmp16_ = table;
				_tmp17_ = toml_value_new_table (_tmp16_);
				_tmp18_ = _tmp17_;
				toml_parser_set_nested_value (self, _tmp14_, _tmp15_, _tmp18_, 0, &_inner_error0_);
				_toml_value_unref0 (_tmp18_);
				if (G_UNLIKELY (_inner_error0_ != NULL)) {
					if (_inner_error0_->domain == TOML_ERROR) {
						g_propagate_error (error, _inner_error0_);
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						return NULL;
					} else {
						_g_object_unref0 (table);
						_g_object_unref0 (keys);
						_g_object_unref0 (root);
						g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
						g_clear_error (&_inner_error0_);
						return NULL;
					}
				}
				_g_object_unref0 (table);
				_g_object_unref0 (keys);
			}
		} else {
			GeeHashMap* _tmp19_;
			_tmp19_ = root;
			toml_parser_parse_key_value (self, _tmp19_, &_inner_error0_);
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == TOML_ERROR) {
					g_propagate_error (error, _inner_error0_);
					_g_object_unref0 (root);
					return NULL;
				} else {
					_g_object_unref0 (root);
					g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
					g_clear_error (&_inner_error0_);
					return NULL;
				}
			}
		}
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == '\n') {
			toml_parser_next (self);
		}
	}
	_tmp20_ = root;
	_tmp21_ = toml_value_new_table (_tmp20_);
	result = _tmp21_;
	_g_object_unref0 (root);
	return result;
}

static void
toml_parser_parse_table_content (TomlParser* self,
                                 GeeHashMap* table,
                                 GError** error)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (table != NULL);
	while (TRUE) {
		const gchar* _tmp0_;
		gint _tmp1_;
		gint _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp0_ = self->priv->input;
		_tmp1_ = strlen (_tmp0_);
		_tmp2_ = _tmp1_;
		if (!(self->priv->pos < _tmp2_)) {
			break;
		}
		toml_parser_skip_whitespace (self);
		toml_parser_skip_comment (self);
		if (toml_parser_peek (self) == '\0') {
			_tmp3_ = TRUE;
		} else {
			_tmp3_ = toml_parser_peek (self) == '[';
		}
		if (_tmp3_) {
			break;
		}
		toml_parser_parse_key_value (self, table, &_inner_error0_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				return;
			} else {
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		toml_parser_skip_whitespace (self);
		if (toml_parser_peek (self) == '\n') {
			toml_parser_next (self);
		}
	}
}

static void
toml_parser_parse_key_value (TomlParser* self,
                             GeeHashMap* table,
                             GError** error)
{
	GeeArrayList* keys = NULL;
	GeeArrayList* _tmp0_;
	gchar* _tmp1_ = NULL;
	gchar* _tmp2_;
	GeeArrayList* _tmp3_;
	TomlValue* val = NULL;
	TomlValue* _tmp8_;
	GeeArrayList* _tmp9_;
	TomlValue* _tmp10_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (table != NULL);
	_tmp0_ = gee_array_list_new (G_TYPE_STRING, (GBoxedCopyFunc) g_strdup, (GDestroyNotify) g_free, NULL, NULL, NULL);
	keys = _tmp0_;
	_tmp2_ = toml_parser_parse_key (self, &_inner_error0_);
	_tmp1_ = _tmp2_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_g_object_unref0 (keys);
			return;
		} else {
			_g_object_unref0 (keys);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp3_ = keys;
	gee_abstract_collection_add ((GeeAbstractCollection*) _tmp3_, _tmp1_);
	while (TRUE) {
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		GeeArrayList* _tmp6_;
		if (!(toml_parser_peek (self) == '.')) {
			break;
		}
		toml_parser_next (self);
		_tmp5_ = toml_parser_parse_key (self, &_inner_error0_);
		_tmp4_ = _tmp5_;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				g_propagate_error (error, _inner_error0_);
				_g_free0 (_tmp1_);
				_g_object_unref0 (keys);
				return;
			} else {
				_g_free0 (_tmp1_);
				_g_object_unref0 (keys);
				g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
		}
		_tmp6_ = keys;
		gee_abstract_collection_add ((GeeAbstractCollection*) _tmp6_, _tmp4_);
		_g_free0 (_tmp4_);
	}
	toml_parser_skip_whitespace (self);
	if (toml_parser_next (self) != '=') {
		GError* _tmp7_;
		_tmp7_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Expected =");
		_inner_error0_ = _tmp7_;
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			return;
		} else {
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp8_ = toml_parser_parse_value (self, &_inner_error0_);
	val = _tmp8_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			return;
		} else {
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp9_ = keys;
	_tmp10_ = val;
	toml_parser_set_nested_value (self, table, _tmp9_, _tmp10_, 0, &_inner_error0_);
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == TOML_ERROR) {
			g_propagate_error (error, _inner_error0_);
			_toml_value_unref0 (val);
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			return;
		} else {
			_toml_value_unref0 (val);
			_g_free0 (_tmp1_);
			_g_object_unref0 (keys);
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_toml_value_unref0 (val);
	_g_free0 (_tmp1_);
	_g_object_unref0 (keys);
}

static gchar*
toml_parser_read_file_content (const gchar* filename,
                               const gchar* encoding,
                               GError** error)
{
	GError* _inner_error0_ = NULL;
	gchar* result;
	g_return_val_if_fail (filename != NULL, NULL);
	{
		GFile* file = NULL;
		GFile* _tmp0_;
		guint8* data = NULL;
		gint data_length1 = 0;
		gint _data_size_ = 0;
		GFile* _tmp1_;
		guint8* _tmp2_ = NULL;
		gsize _tmp3_ = 0;
		gchar* _tmp4_ = NULL;
		gchar* _tmp5_;
		gchar* detected_encoding = NULL;
		gchar* _tmp8_;
		gboolean _tmp9_ = FALSE;
		const gchar* _tmp10_;
		_tmp0_ = g_file_new_for_path (filename);
		file = _tmp0_;
		_tmp1_ = file;
		g_file_load_contents (_tmp1_, NULL, &_tmp2_, &_tmp3_, NULL, &_inner_error0_);
		data = (g_free (data), NULL);
		data = _tmp2_;
		data_length1 = _tmp3_;
		_data_size_ = data_length1;
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			data = (g_free (data), NULL);
			_g_object_unref0 (file);
			goto __catch0_g_error;
		}
		_tmp5_ = g_strdup (encoding);
		_tmp4_ = _tmp5_;
		if (_tmp4_ == NULL) {
			guint8* _tmp6_;
			gint _tmp6__length1;
			gchar* _tmp7_;
			_tmp6_ = data;
			_tmp6__length1 = data_length1;
			_tmp7_ = toml_parser_detect_encoding (_tmp6_, (gint) _tmp6__length1);
			_g_free0 (_tmp4_);
			_tmp4_ = _tmp7_;
		}
		_tmp8_ = _tmp4_;
		_tmp4_ = NULL;
		detected_encoding = _tmp8_;
		_tmp10_ = detected_encoding;
		if (g_strcmp0 (_tmp10_, "UTF-8") == 0) {
			_tmp9_ = TRUE;
		} else {
			const gchar* _tmp11_;
			_tmp11_ = detected_encoding;
			_tmp9_ = g_strcmp0 (_tmp11_, "ASCII") == 0;
		}
		if (_tmp9_) {
			guint8* _tmp12_;
			gint _tmp12__length1;
			gchar* _tmp13_;
			_tmp12_ = data;
			_tmp12__length1 = data_length1;
			_tmp13_ = g_strdup ((const gchar*) _tmp12_);
			result = _tmp13_;
			_g_free0 (detected_encoding);
			_g_free0 (_tmp4_);
			data = (g_free (data), NULL);
			_g_object_unref0 (file);
			return result;
		} else {
			gsize bytes_read = 0UL;
			gsize bytes_written = 0UL;
			gchar* content = NULL;
			guint8* _tmp14_;
			gint _tmp14__length1;
			const gchar* _tmp15_;
			gsize _tmp16_ = 0UL;
			gsize _tmp17_ = 0UL;
			gchar* _tmp18_;
			const gchar* _tmp19_;
			_tmp14_ = data;
			_tmp14__length1 = data_length1;
			_tmp15_ = detected_encoding;
			_tmp18_ = g_convert ((const gchar*) _tmp14_, (gssize) -1, "UTF-8", _tmp15_, &_tmp16_, &_tmp17_, &_inner_error0_);
			bytes_read = _tmp16_;
			bytes_written = _tmp17_;
			content = _tmp18_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				_g_free0 (detected_encoding);
				_g_free0 (_tmp4_);
				data = (g_free (data), NULL);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			_tmp19_ = content;
			if (_tmp19_ == NULL) {
				GError* _tmp20_;
				_tmp20_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Failed to convert encoding");
				_inner_error0_ = _tmp20_;
				_g_free0 (content);
				_g_free0 (detected_encoding);
				_g_free0 (_tmp4_);
				data = (g_free (data), NULL);
				_g_object_unref0 (file);
				goto __catch0_g_error;
			}
			result = content;
			_g_free0 (detected_encoding);
			_g_free0 (_tmp4_);
			data = (g_free (data), NULL);
			_g_object_unref0 (file);
			return result;
		}
		_g_free0 (detected_encoding);
		_g_free0 (_tmp4_);
		data = (g_free (data), NULL);
		_g_object_unref0 (file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		GError* e = NULL;
		GError* _tmp21_;
		const gchar* _tmp22_;
		gchar* _tmp23_;
		gchar* _tmp24_;
		GError* _tmp25_;
		GError* _tmp26_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp21_ = e;
		_tmp22_ = _tmp21_->message;
		_tmp23_ = g_strconcat ("Failed to read file: ", _tmp22_, NULL);
		_tmp24_ = _tmp23_;
		_tmp25_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, _tmp24_);
		_tmp26_ = _tmp25_;
		_g_free0 (_tmp24_);
		_inner_error0_ = _tmp26_;
		_g_error_free0 (e);
		goto __finally0;
	}
	__finally0:
	if (_inner_error0_->domain == TOML_ERROR) {
		g_propagate_error (error, _inner_error0_);
		return NULL;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
}

static gchar*
toml_parser_detect_encoding (guint8* data,
                             gint data_length1)
{
	gchar* _tmp30_;
	gchar* result;
	if (data_length1 >= 4) {
		gboolean _tmp0_ = FALSE;
		gboolean _tmp1_ = FALSE;
		gboolean _tmp2_ = FALSE;
		guint8 _tmp3_;
		_tmp3_ = data[0];
		if (((gint) _tmp3_) == 0x00) {
			guint8 _tmp4_;
			_tmp4_ = data[1];
			_tmp2_ = ((gint) _tmp4_) == 0x00;
		} else {
			_tmp2_ = FALSE;
		}
		if (_tmp2_) {
			guint8 _tmp5_;
			_tmp5_ = data[2];
			_tmp1_ = ((gint) _tmp5_) == 0xFE;
		} else {
			_tmp1_ = FALSE;
		}
		if (_tmp1_) {
			guint8 _tmp6_;
			_tmp6_ = data[3];
			_tmp0_ = ((gint) _tmp6_) == 0xFF;
		} else {
			_tmp0_ = FALSE;
		}
		if (_tmp0_) {
			gchar* _tmp7_;
			_tmp7_ = g_strdup ("UTF-32BE");
			result = _tmp7_;
			return result;
		} else {
			gboolean _tmp8_ = FALSE;
			gboolean _tmp9_ = FALSE;
			gboolean _tmp10_ = FALSE;
			guint8 _tmp11_;
			_tmp11_ = data[0];
			if (((gint) _tmp11_) == 0xFF) {
				guint8 _tmp12_;
				_tmp12_ = data[1];
				_tmp10_ = ((gint) _tmp12_) == 0xFE;
			} else {
				_tmp10_ = FALSE;
			}
			if (_tmp10_) {
				guint8 _tmp13_;
				_tmp13_ = data[2];
				_tmp9_ = ((gint) _tmp13_) == 0x00;
			} else {
				_tmp9_ = FALSE;
			}
			if (_tmp9_) {
				guint8 _tmp14_;
				_tmp14_ = data[3];
				_tmp8_ = ((gint) _tmp14_) == 0x00;
			} else {
				_tmp8_ = FALSE;
			}
			if (_tmp8_) {
				gchar* _tmp15_;
				_tmp15_ = g_strdup ("UTF-32LE");
				result = _tmp15_;
				return result;
			}
		}
	}
	if (data_length1 >= 3) {
		gboolean _tmp16_ = FALSE;
		gboolean _tmp17_ = FALSE;
		guint8 _tmp18_;
		_tmp18_ = data[0];
		if (((gint) _tmp18_) == 0xEF) {
			guint8 _tmp19_;
			_tmp19_ = data[1];
			_tmp17_ = ((gint) _tmp19_) == 0xBB;
		} else {
			_tmp17_ = FALSE;
		}
		if (_tmp17_) {
			guint8 _tmp20_;
			_tmp20_ = data[2];
			_tmp16_ = ((gint) _tmp20_) == 0xBF;
		} else {
			_tmp16_ = FALSE;
		}
		if (_tmp16_) {
			gchar* _tmp21_;
			_tmp21_ = g_strdup ("UTF-8");
			result = _tmp21_;
			return result;
		}
	}
	if (data_length1 >= 2) {
		gboolean _tmp22_ = FALSE;
		guint8 _tmp23_;
		_tmp23_ = data[0];
		if (((gint) _tmp23_) == 0xFE) {
			guint8 _tmp24_;
			_tmp24_ = data[1];
			_tmp22_ = ((gint) _tmp24_) == 0xFF;
		} else {
			_tmp22_ = FALSE;
		}
		if (_tmp22_) {
			gchar* _tmp25_;
			_tmp25_ = g_strdup ("UTF-16BE");
			result = _tmp25_;
			return result;
		} else {
			gboolean _tmp26_ = FALSE;
			guint8 _tmp27_;
			_tmp27_ = data[0];
			if (((gint) _tmp27_) == 0xFF) {
				guint8 _tmp28_;
				_tmp28_ = data[1];
				_tmp26_ = ((gint) _tmp28_) == 0xFE;
			} else {
				_tmp26_ = FALSE;
			}
			if (_tmp26_) {
				gchar* _tmp29_;
				_tmp29_ = g_strdup ("UTF-16LE");
				result = _tmp29_;
				return result;
			}
		}
	}
	_tmp30_ = g_strdup ("UTF-8");
	result = _tmp30_;
	return result;
}

static void
toml_parser_read_file_content_async_data_free (gpointer _data)
{
	TomlParserReadFileContentAsyncData* _data_;
	_data_ = _data;
	_g_free0 (_data_->filename);
	_g_free0 (_data_->encoding);
	_g_free0 (_data_->result);
	g_slice_free (TomlParserReadFileContentAsyncData, _data_);
}

static void
toml_parser_read_file_content_async (const gchar* filename,
                                     const gchar* encoding,
                                     GAsyncReadyCallback _callback_,
                                     gpointer _user_data_)
{
	TomlParserReadFileContentAsyncData* _data_;
	gchar* _tmp0_;
	gchar* _tmp1_;
	g_return_if_fail (filename != NULL);
	_data_ = g_slice_new0 (TomlParserReadFileContentAsyncData);
	_data_->_async_result = g_task_new (NULL, NULL, _callback_, _user_data_);
	g_task_set_task_data (_data_->_async_result, _data_, toml_parser_read_file_content_async_data_free);
	_tmp0_ = g_strdup (filename);
	_g_free0 (_data_->filename);
	_data_->filename = _tmp0_;
	_tmp1_ = g_strdup (encoding);
	_g_free0 (_data_->encoding);
	_data_->encoding = _tmp1_;
	toml_parser_read_file_content_async_co (_data_);
}

static gchar*
toml_parser_read_file_content_finish (GAsyncResult* _res_,
                                      GError** error)
{
	gchar* result;
	TomlParserReadFileContentAsyncData* _data_;
	_data_ = g_task_propagate_pointer (G_TASK (_res_), error);
	if (NULL == _data_) {
		return NULL;
	}
	result = _data_->result;
	_data_->result = NULL;
	return result;
}

static void
toml_parser_read_file_content_async_ready (GObject* source_object,
                                           GAsyncResult* _res_,
                                           gpointer _user_data_)
{
	TomlParserReadFileContentAsyncData* _data_;
	_data_ = _user_data_;
	_data_->_source_object_ = source_object;
	_data_->_res_ = _res_;
	toml_parser_read_file_content_async_co (_data_);
}

static gboolean
toml_parser_read_file_content_async_co (TomlParserReadFileContentAsyncData* _data_)
{
	switch (_data_->_state_) {
		case 0:
		goto _state_0;
		case 1:
		goto _state_1;
		default:
		g_assert_not_reached ();
	}
	_state_0:
	{
		_data_->_tmp0_ = g_file_new_for_path (_data_->filename);
		_data_->file = _data_->_tmp0_;
		_data_->data_length1 = 0;
		_data_->_data_size_ = 0;
		_data_->_tmp1_ = _data_->file;
		_data_->_tmp2_ = NULL;
		_data_->_tmp3_ = 0;
		_data_->_state_ = 1;
		g_file_load_contents_async (_data_->_tmp1_, NULL, toml_parser_read_file_content_async_ready, _data_);
		return FALSE;
		_state_1:
		g_file_load_contents_finish (_data_->_tmp1_, _data_->_res_, &_data_->_tmp2_, &_data_->_tmp3_, NULL, &_data_->_inner_error0_);
		_data_->data = (g_free (_data_->data), NULL);
		_data_->data = _data_->_tmp2_;
		_data_->data_length1 = _data_->_tmp3_;
		_data_->_data_size_ = _data_->data_length1;
		if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
			_data_->data = (g_free (_data_->data), NULL);
			_g_object_unref0 (_data_->file);
			goto __catch0_g_error;
		}
		_data_->_tmp5_ = g_strdup (_data_->encoding);
		_data_->_tmp4_ = _data_->_tmp5_;
		if (_data_->_tmp4_ == NULL) {
			_data_->_tmp6_ = _data_->data;
			_data_->_tmp6__length1 = _data_->data_length1;
			_data_->_tmp7_ = toml_parser_detect_encoding (_data_->_tmp6_, (gint) _data_->_tmp6__length1);
			_g_free0 (_data_->_tmp4_);
			_data_->_tmp4_ = _data_->_tmp7_;
		}
		_data_->_tmp8_ = _data_->_tmp4_;
		_data_->_tmp4_ = NULL;
		_data_->detected_encoding = _data_->_tmp8_;
		_data_->_tmp10_ = _data_->detected_encoding;
		if (g_strcmp0 (_data_->_tmp10_, "UTF-8") == 0) {
			_data_->_tmp9_ = TRUE;
		} else {
			_data_->_tmp11_ = _data_->detected_encoding;
			_data_->_tmp9_ = g_strcmp0 (_data_->_tmp11_, "ASCII") == 0;
		}
		if (_data_->_tmp9_) {
			_data_->_tmp12_ = _data_->data;
			_data_->_tmp12__length1 = _data_->data_length1;
			_data_->_tmp13_ = g_strdup ((const gchar*) _data_->_tmp12_);
			_data_->result = _data_->_tmp13_;
			_g_free0 (_data_->detected_encoding);
			_g_free0 (_data_->_tmp4_);
			_data_->data = (g_free (_data_->data), NULL);
			_g_object_unref0 (_data_->file);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		} else {
			_data_->_tmp14_ = _data_->data;
			_data_->_tmp14__length1 = _data_->data_length1;
			_data_->_tmp15_ = _data_->detected_encoding;
			_data_->_tmp16_ = 0UL;
			_data_->_tmp17_ = 0UL;
			_data_->_tmp18_ = g_convert ((const gchar*) _data_->_tmp14_, (gssize) -1, "UTF-8", _data_->_tmp15_, &_data_->_tmp16_, &_data_->_tmp17_, &_data_->_inner_error0_);
			_data_->bytes_read = _data_->_tmp16_;
			_data_->bytes_written = _data_->_tmp17_;
			_data_->content = _data_->_tmp18_;
			if (G_UNLIKELY (_data_->_inner_error0_ != NULL)) {
				_g_free0 (_data_->detected_encoding);
				_g_free0 (_data_->_tmp4_);
				_data_->data = (g_free (_data_->data), NULL);
				_g_object_unref0 (_data_->file);
				goto __catch0_g_error;
			}
			_data_->_tmp19_ = _data_->content;
			if (_data_->_tmp19_ == NULL) {
				_data_->_tmp20_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, "Failed to convert encoding");
				_data_->_inner_error0_ = _data_->_tmp20_;
				_g_free0 (_data_->content);
				_g_free0 (_data_->detected_encoding);
				_g_free0 (_data_->_tmp4_);
				_data_->data = (g_free (_data_->data), NULL);
				_g_object_unref0 (_data_->file);
				goto __catch0_g_error;
			}
			_data_->result = _data_->content;
			_g_free0 (_data_->detected_encoding);
			_g_free0 (_data_->_tmp4_);
			_data_->data = (g_free (_data_->data), NULL);
			_g_object_unref0 (_data_->file);
			g_task_return_pointer (_data_->_async_result, _data_, NULL);
			if (_data_->_state_ != 0) {
				while (!g_task_get_completed (_data_->_async_result)) {
					g_main_context_iteration (g_task_get_context (_data_->_async_result), TRUE);
				}
			}
			g_object_unref (_data_->_async_result);
			return FALSE;
		}
		_g_free0 (_data_->detected_encoding);
		_g_free0 (_data_->_tmp4_);
		_data_->data = (g_free (_data_->data), NULL);
		_g_object_unref0 (_data_->file);
	}
	goto __finally0;
	__catch0_g_error:
	{
		_data_->e = _data_->_inner_error0_;
		_data_->_inner_error0_ = NULL;
		_data_->_tmp21_ = _data_->e;
		_data_->_tmp22_ = _data_->_tmp21_->message;
		_data_->_tmp23_ = g_strconcat ("Failed to read file: ", _data_->_tmp22_, NULL);
		_data_->_tmp24_ = _data_->_tmp23_;
		_data_->_tmp25_ = g_error_new_literal (TOML_ERROR, TOML_ERROR_INVALID_SYNTAX, _data_->_tmp24_);
		_data_->_tmp26_ = _data_->_tmp25_;
		_g_free0 (_data_->_tmp24_);
		_data_->_inner_error0_ = _data_->_tmp26_;
		_g_error_free0 (_data_->e);
		goto __finally0;
	}
	__finally0:
	if (_data_->_inner_error0_->domain == TOML_ERROR) {
		g_task_return_error (_data_->_async_result, _data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	} else {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _data_->_inner_error0_->message, g_quark_to_string (_data_->_inner_error0_->domain), _data_->_inner_error0_->code);
		g_clear_error (&_data_->_inner_error0_);
		g_object_unref (_data_->_async_result);
		return FALSE;
	}
}

static void
value_toml_parser_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_toml_parser_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		toml_parser_unref (value->data[0].v_pointer);
	}
}

static void
value_toml_parser_copy_value (const GValue* src_value,
                              GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = toml_parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_toml_parser_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_toml_parser_collect_value (GValue* value,
                                 guint n_collect_values,
                                 GTypeCValue* collect_values,
                                 guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		TomlParser * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = toml_parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_toml_parser_lcopy_value (const GValue* value,
                               guint n_collect_values,
                               GTypeCValue* collect_values,
                               guint collect_flags)
{
	TomlParser ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = toml_parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_toml_parser (const gchar* name,
                        const gchar* nick,
                        const gchar* blurb,
                        GType object_type,
                        GParamFlags flags)
{
	ParamSpecTomlParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TOML_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_toml_parser (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_PARSER), NULL);
	return value->data[0].v_pointer;
}

void
value_set_toml_parser (GValue* value,
                       gpointer v_object)
{
	TomlParser * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		toml_parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_parser_unref (old);
	}
}

void
value_take_toml_parser (GValue* value,
                        gpointer v_object)
{
	TomlParser * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_parser_unref (old);
	}
}

static void
toml_parser_class_init (TomlParserClass * klass,
                        gpointer klass_data)
{
	toml_parser_parent_class = g_type_class_peek_parent (klass);
	((TomlParserClass *) klass)->finalize = toml_parser_finalize;
	g_type_class_adjust_private_offset (klass, &TomlParser_private_offset);
}

static void
toml_parser_instance_init (TomlParser * self,
                           gpointer klass)
{
	self->priv = toml_parser_get_instance_private (self);
	self->ref_count = 1;
}

static void
toml_parser_finalize (TomlParser * obj)
{
	TomlParser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TOML_PARSER, TomlParser);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->input);
}

static GType
toml_parser_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_toml_parser_init, value_toml_parser_free_value, value_toml_parser_copy_value, value_toml_parser_peek_pointer, "p", value_toml_parser_collect_value, "p", value_toml_parser_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (TomlParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) toml_parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TomlParser), 0, (GInstanceInitFunc) toml_parser_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType toml_parser_type_id;
	toml_parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TomlParser", &g_define_type_info, &g_define_type_fundamental_info, 0);
	TomlParser_private_offset = g_type_add_instance_private (toml_parser_type_id, sizeof (TomlParserPrivate));
	return toml_parser_type_id;
}

GType
toml_parser_get_type (void)
{
	static volatile gsize toml_parser_type_id__once = 0;
	if (g_once_init_enter (&toml_parser_type_id__once)) {
		GType toml_parser_type_id;
		toml_parser_type_id = toml_parser_get_type_once ();
		g_once_init_leave (&toml_parser_type_id__once, toml_parser_type_id);
	}
	return toml_parser_type_id__once;
}

gpointer
toml_parser_ref (gpointer instance)
{
	TomlParser * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
toml_parser_unref (gpointer instance)
{
	TomlParser * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		TOML_PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
toml_watcher_get_instance_private (TomlWatcher* self)
{
	return G_STRUCT_MEMBER_P (self, TomlWatcher_private_offset);
}

TomlWatcher*
toml_watcher_construct (GType object_type,
                        const gchar* filename)
{
	TomlWatcher* self = NULL;
	GFile* _tmp0_;
	g_return_val_if_fail (filename != NULL, NULL);
	self = (TomlWatcher*) g_type_create_instance (object_type);
	_tmp0_ = g_file_new_for_path (filename);
	_g_object_unref0 (self->priv->file);
	self->priv->file = _tmp0_;
	self->priv->watching = FALSE;
	return self;
}

TomlWatcher*
toml_watcher_new (const gchar* filename)
{
	return toml_watcher_construct (TYPE_TOML_WATCHER, filename);
}

static void
_toml_watcher_on_file_changed_g_file_monitor_changed (GFileMonitor* _sender,
                                                      GFile* file,
                                                      GFile* other_file,
                                                      GFileMonitorEvent event_type,
                                                      gpointer self)
{
	toml_watcher_on_file_changed ((TomlWatcher*) self, file, other_file, event_type);
}

void
toml_watcher_start (TomlWatcher* self,
                    GError** error)
{
	GFileMonitor* _tmp0_ = NULL;
	GFile* _tmp1_;
	GFileMonitor* _tmp2_;
	GFileMonitor* _tmp3_;
	GFileMonitor* _tmp4_;
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	if (self->priv->watching) {
		return;
	}
	_tmp1_ = self->priv->file;
	_tmp2_ = g_file_monitor_file (_tmp1_, G_FILE_MONITOR_NONE, NULL, &_inner_error0_);
	_tmp0_ = _tmp2_;
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		if (_inner_error0_->domain == G_IO_ERROR) {
			g_propagate_error (error, _inner_error0_);
			return;
		} else {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
	_tmp3_ = _tmp0_;
	_tmp0_ = NULL;
	_g_object_unref0 (self->priv->monitor);
	self->priv->monitor = _tmp3_;
	_tmp4_ = self->priv->monitor;
	g_signal_connect (_tmp4_, "changed", (GCallback) _toml_watcher_on_file_changed_g_file_monitor_changed, self);
	self->priv->watching = TRUE;
	_g_object_unref0 (_tmp0_);
}

void
toml_watcher_stop (TomlWatcher* self)
{
	GFileMonitor* _tmp0_;
	g_return_if_fail (self != NULL);
	if (!self->priv->watching) {
		return;
	}
	_tmp0_ = self->priv->monitor;
	g_file_monitor_cancel (_tmp0_);
	self->priv->watching = FALSE;
}

static void
toml_watcher_on_file_changed (TomlWatcher* self,
                              GFile* file,
                              GFile* other_file,
                              GFileMonitorEvent event_type)
{
	GError* _inner_error0_ = NULL;
	g_return_if_fail (self != NULL);
	g_return_if_fail (file != NULL);
	if (event_type == G_FILE_MONITOR_EVENT_CHANGES_DONE_HINT) {
		{
			TomlValue* root = NULL;
			gchar* _tmp0_;
			gchar* _tmp1_;
			TomlValue* _tmp2_;
			TomlValue* _tmp3_;
			TomlValue* _tmp4_;
			_tmp0_ = g_file_get_path (file);
			_tmp1_ = _tmp0_;
			_tmp2_ = toml_parser_parse_file (_tmp1_, NULL, &_inner_error0_);
			_tmp3_ = _tmp2_;
			_g_free0 (_tmp1_);
			root = _tmp3_;
			if (G_UNLIKELY (_inner_error0_ != NULL)) {
				if (_inner_error0_->domain == TOML_ERROR) {
					goto __catch0_toml_error;
				}
				g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
				g_clear_error (&_inner_error0_);
				return;
			}
			_tmp4_ = root;
			g_signal_emit (self, toml_watcher_signals[TOML_WATCHER_CHANGED_SIGNAL], 0, _tmp4_);
			_toml_value_unref0 (root);
		}
		goto __finally0;
		__catch0_toml_error:
		{
			g_clear_error (&_inner_error0_);
		}
		__finally0:
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return;
		}
	}
}

static void
g_cclosure_user_marshal_VOID__TOML_VALUE (GClosure * closure,
                                          GValue * return_value,
                                          guint n_param_values,
                                          const GValue * param_values,
                                          gpointer invocation_hint,
                                          gpointer marshal_data)
{
	typedef void (*GMarshalFunc_VOID__TOML_VALUE) (gpointer data1, gpointer arg_1, gpointer data2);
	register GMarshalFunc_VOID__TOML_VALUE callback;
	register GCClosure * cc;
	register gpointer data1;
	register gpointer data2;
	cc = (GCClosure *) closure;
	g_return_if_fail (n_param_values == 2);
	if (G_CCLOSURE_SWAP_DATA (closure)) {
		data1 = closure->data;
		data2 = param_values->data[0].v_pointer;
	} else {
		data1 = param_values->data[0].v_pointer;
		data2 = closure->data;
	}
	callback = (GMarshalFunc_VOID__TOML_VALUE) (marshal_data ? marshal_data : cc->callback);
	callback (data1, value_get_toml_value (param_values + 1), data2);
}

static void
value_toml_watcher_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_toml_watcher_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		toml_watcher_unref (value->data[0].v_pointer);
	}
}

static void
value_toml_watcher_copy_value (const GValue* src_value,
                               GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = toml_watcher_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_toml_watcher_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_toml_watcher_collect_value (GValue* value,
                                  guint n_collect_values,
                                  GTypeCValue* collect_values,
                                  guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		TomlWatcher * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = toml_watcher_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_toml_watcher_lcopy_value (const GValue* value,
                                guint n_collect_values,
                                GTypeCValue* collect_values,
                                guint collect_flags)
{
	TomlWatcher ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = toml_watcher_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_toml_watcher (const gchar* name,
                         const gchar* nick,
                         const gchar* blurb,
                         GType object_type,
                         GParamFlags flags)
{
	ParamSpecTomlWatcher* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TOML_WATCHER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_toml_watcher (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_WATCHER), NULL);
	return value->data[0].v_pointer;
}

void
value_set_toml_watcher (GValue* value,
                        gpointer v_object)
{
	TomlWatcher * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_WATCHER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_WATCHER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		toml_watcher_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_watcher_unref (old);
	}
}

void
value_take_toml_watcher (GValue* value,
                         gpointer v_object)
{
	TomlWatcher * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_WATCHER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_WATCHER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_watcher_unref (old);
	}
}

static void
toml_watcher_class_init (TomlWatcherClass * klass,
                         gpointer klass_data)
{
	toml_watcher_parent_class = g_type_class_peek_parent (klass);
	((TomlWatcherClass *) klass)->finalize = toml_watcher_finalize;
	g_type_class_adjust_private_offset (klass, &TomlWatcher_private_offset);
	toml_watcher_signals[TOML_WATCHER_CHANGED_SIGNAL] = g_signal_new ("changed", TYPE_TOML_WATCHER, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_user_marshal_VOID__TOML_VALUE, G_TYPE_NONE, 1, TYPE_TOML_VALUE);
}

static void
toml_watcher_instance_init (TomlWatcher * self,
                            gpointer klass)
{
	self->priv = toml_watcher_get_instance_private (self);
	self->ref_count = 1;
}

static void
toml_watcher_finalize (TomlWatcher * obj)
{
	TomlWatcher * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TOML_WATCHER, TomlWatcher);
	g_signal_handlers_destroy (self);
	_g_object_unref0 (self->priv->file);
	_g_object_unref0 (self->priv->monitor);
}

static GType
toml_watcher_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_toml_watcher_init, value_toml_watcher_free_value, value_toml_watcher_copy_value, value_toml_watcher_peek_pointer, "p", value_toml_watcher_collect_value, "p", value_toml_watcher_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (TomlWatcherClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) toml_watcher_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TomlWatcher), 0, (GInstanceInitFunc) toml_watcher_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType toml_watcher_type_id;
	toml_watcher_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TomlWatcher", &g_define_type_info, &g_define_type_fundamental_info, 0);
	TomlWatcher_private_offset = g_type_add_instance_private (toml_watcher_type_id, sizeof (TomlWatcherPrivate));
	return toml_watcher_type_id;
}

GType
toml_watcher_get_type (void)
{
	static volatile gsize toml_watcher_type_id__once = 0;
	if (g_once_init_enter (&toml_watcher_type_id__once)) {
		GType toml_watcher_type_id;
		toml_watcher_type_id = toml_watcher_get_type_once ();
		g_once_init_leave (&toml_watcher_type_id__once, toml_watcher_type_id);
	}
	return toml_watcher_type_id__once;
}

gpointer
toml_watcher_ref (gpointer instance)
{
	TomlWatcher * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
toml_watcher_unref (gpointer instance)
{
	TomlWatcher * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		TOML_WATCHER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

static inline gpointer
toml_validation_error_get_instance_private (TomlValidationError* self)
{
	return G_STRUCT_MEMBER_P (self, TomlValidationError_private_offset);
}

TomlValidationError*
toml_validation_error_construct (GType object_type,
                                 const gchar* msg,
                                 gint l,
                                 gint c,
                                 const gchar* sugg)
{
	TomlValidationError* self = NULL;
	g_return_val_if_fail (msg != NULL, NULL);
	g_return_val_if_fail (sugg != NULL, NULL);
	self = (TomlValidationError*) g_type_create_instance (object_type);
	toml_validation_error_set_message (self, msg);
	toml_validation_error_set_line (self, l);
	toml_validation_error_set_col (self, c);
	toml_validation_error_set_suggestion (self, sugg);
	return self;
}

TomlValidationError*
toml_validation_error_new (const gchar* msg,
                           gint l,
                           gint c,
                           const gchar* sugg)
{
	return toml_validation_error_construct (TYPE_TOML_VALIDATION_ERROR, msg, l, c, sugg);
}

const gchar*
toml_validation_error_get_message (TomlValidationError* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_message;
	result = _tmp0_;
	return result;
}

static void
toml_validation_error_set_message (TomlValidationError* self,
                                   const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_message);
	self->priv->_message = _tmp0_;
}

gint
toml_validation_error_get_line (TomlValidationError* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_line;
	return result;
}

static void
toml_validation_error_set_line (TomlValidationError* self,
                                gint value)
{
	g_return_if_fail (self != NULL);
	self->priv->_line = value;
}

gint
toml_validation_error_get_col (TomlValidationError* self)
{
	gint result;
	g_return_val_if_fail (self != NULL, 0);
	result = self->priv->_col;
	return result;
}

static void
toml_validation_error_set_col (TomlValidationError* self,
                               gint value)
{
	g_return_if_fail (self != NULL);
	self->priv->_col = value;
}

const gchar*
toml_validation_error_get_suggestion (TomlValidationError* self)
{
	const gchar* result;
	const gchar* _tmp0_;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->_suggestion;
	result = _tmp0_;
	return result;
}

static void
toml_validation_error_set_suggestion (TomlValidationError* self,
                                      const gchar* value)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	_tmp0_ = g_strdup (value);
	_g_free0 (self->priv->_suggestion);
	self->priv->_suggestion = _tmp0_;
}

static void
value_toml_validation_error_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_toml_validation_error_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		toml_validation_error_unref (value->data[0].v_pointer);
	}
}

static void
value_toml_validation_error_copy_value (const GValue* src_value,
                                        GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = toml_validation_error_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_toml_validation_error_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_toml_validation_error_collect_value (GValue* value,
                                           guint n_collect_values,
                                           GTypeCValue* collect_values,
                                           guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		TomlValidationError * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = toml_validation_error_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_toml_validation_error_lcopy_value (const GValue* value,
                                         guint n_collect_values,
                                         GTypeCValue* collect_values,
                                         guint collect_flags)
{
	TomlValidationError ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = toml_validation_error_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_toml_validation_error (const gchar* name,
                                  const gchar* nick,
                                  const gchar* blurb,
                                  GType object_type,
                                  GParamFlags flags)
{
	ParamSpecTomlValidationError* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TOML_VALIDATION_ERROR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_toml_validation_error (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATION_ERROR), NULL);
	return value->data[0].v_pointer;
}

void
value_set_toml_validation_error (GValue* value,
                                 gpointer v_object)
{
	TomlValidationError * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATION_ERROR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALIDATION_ERROR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		toml_validation_error_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_validation_error_unref (old);
	}
}

void
value_take_toml_validation_error (GValue* value,
                                  gpointer v_object)
{
	TomlValidationError * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATION_ERROR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALIDATION_ERROR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_validation_error_unref (old);
	}
}

static void
toml_validation_error_class_init (TomlValidationErrorClass * klass,
                                  gpointer klass_data)
{
	toml_validation_error_parent_class = g_type_class_peek_parent (klass);
	((TomlValidationErrorClass *) klass)->finalize = toml_validation_error_finalize;
	g_type_class_adjust_private_offset (klass, &TomlValidationError_private_offset);
}

static void
toml_validation_error_instance_init (TomlValidationError * self,
                                     gpointer klass)
{
	self->priv = toml_validation_error_get_instance_private (self);
	self->ref_count = 1;
}

static void
toml_validation_error_finalize (TomlValidationError * obj)
{
	TomlValidationError * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TOML_VALIDATION_ERROR, TomlValidationError);
	g_signal_handlers_destroy (self);
	_g_free0 (self->priv->_message);
	_g_free0 (self->priv->_suggestion);
}

static GType
toml_validation_error_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_toml_validation_error_init, value_toml_validation_error_free_value, value_toml_validation_error_copy_value, value_toml_validation_error_peek_pointer, "p", value_toml_validation_error_collect_value, "p", value_toml_validation_error_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (TomlValidationErrorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) toml_validation_error_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TomlValidationError), 0, (GInstanceInitFunc) toml_validation_error_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType toml_validation_error_type_id;
	toml_validation_error_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TomlValidationError", &g_define_type_info, &g_define_type_fundamental_info, 0);
	TomlValidationError_private_offset = g_type_add_instance_private (toml_validation_error_type_id, sizeof (TomlValidationErrorPrivate));
	return toml_validation_error_type_id;
}

GType
toml_validation_error_get_type (void)
{
	static volatile gsize toml_validation_error_type_id__once = 0;
	if (g_once_init_enter (&toml_validation_error_type_id__once)) {
		GType toml_validation_error_type_id;
		toml_validation_error_type_id = toml_validation_error_get_type_once ();
		g_once_init_leave (&toml_validation_error_type_id__once, toml_validation_error_type_id);
	}
	return toml_validation_error_type_id__once;
}

gpointer
toml_validation_error_ref (gpointer instance)
{
	TomlValidationError * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
toml_validation_error_unref (gpointer instance)
{
	TomlValidationError * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		TOML_VALIDATION_ERROR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

GeeArrayList*
toml_validator_validate_file (const gchar* filename,
                              const gchar* encoding)
{
	GeeArrayList* errors = NULL;
	GeeArrayList* _tmp0_;
	GError* _inner_error0_ = NULL;
	GeeArrayList* result;
	g_return_val_if_fail (filename != NULL, NULL);
	_tmp0_ = gee_array_list_new (TYPE_TOML_VALIDATION_ERROR, (GBoxedCopyFunc) toml_validation_error_ref, (GDestroyNotify) toml_validation_error_unref, NULL, NULL, NULL);
	errors = _tmp0_;
	{
		TomlValue* _tmp1_;
		TomlValue* _tmp2_;
		_tmp1_ = toml_parser_parse_file (filename, encoding, &_inner_error0_);
		_tmp2_ = _tmp1_;
		_toml_value_unref0 (_tmp2_);
		if (G_UNLIKELY (_inner_error0_ != NULL)) {
			if (_inner_error0_->domain == TOML_ERROR) {
				goto __catch0_toml_error;
			}
			_g_object_unref0 (errors);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
			g_clear_error (&_inner_error0_);
			return NULL;
		}
	}
	goto __finally0;
	__catch0_toml_error:
	{
		GError* e = NULL;
		gchar* suggestion = NULL;
		gchar* _tmp3_;
		GError* _tmp4_;
		GError* _tmp12_;
		const gchar* _tmp13_;
		const gchar* _tmp14_;
		TomlValidationError* _tmp15_;
		TomlValidationError* _tmp16_;
		e = _inner_error0_;
		_inner_error0_ = NULL;
		_tmp3_ = g_strdup ("");
		suggestion = _tmp3_;
		_tmp4_ = e;
		if (g_error_matches (_tmp4_, TOML_ERROR, TOML_ERROR_INVALID_SYNTAX)) {
			gchar* _tmp5_;
			_tmp5_ = g_strdup ("Check the TOML syntax at the indicated position. Ensure keys are prope" \
"rly quoted if necessary, and values match expected types.");
			_g_free0 (suggestion);
			suggestion = _tmp5_;
		} else {
			GError* _tmp6_;
			_tmp6_ = e;
			if (g_error_matches (_tmp6_, TOML_ERROR, TOML_ERROR_INVALID_VALUE)) {
				gchar* _tmp7_;
				_tmp7_ = g_strdup ("Verify the value format. For example, strings should be quoted, number" \
"s should not contain invalid characters.");
				_g_free0 (suggestion);
				suggestion = _tmp7_;
			} else {
				GError* _tmp8_;
				_tmp8_ = e;
				if (g_error_matches (_tmp8_, TOML_ERROR, TOML_ERROR_DUPLICATE_KEY)) {
					gchar* _tmp9_;
					_tmp9_ = g_strdup ("Remove or rename duplicate keys in the same table.");
					_g_free0 (suggestion);
					suggestion = _tmp9_;
				} else {
					GError* _tmp10_;
					_tmp10_ = e;
					if (g_error_matches (_tmp10_, TOML_ERROR, TOML_ERROR_MISSING_KEY)) {
						gchar* _tmp11_;
						_tmp11_ = g_strdup ("Ensure all required keys are present.");
						_g_free0 (suggestion);
						suggestion = _tmp11_;
					}
				}
			}
		}
		_tmp12_ = e;
		_tmp13_ = _tmp12_->message;
		_tmp14_ = suggestion;
		_tmp15_ = toml_validation_error_new (_tmp13_, 0, 0, _tmp14_);
		_tmp16_ = _tmp15_;
		gee_abstract_collection_add ((GeeAbstractCollection*) errors, _tmp16_);
		_toml_validation_error_unref0 (_tmp16_);
		_g_free0 (suggestion);
		_g_error_free0 (e);
	}
	__finally0:
	if (G_UNLIKELY (_inner_error0_ != NULL)) {
		_g_object_unref0 (errors);
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error0_->message, g_quark_to_string (_inner_error0_->domain), _inner_error0_->code);
		g_clear_error (&_inner_error0_);
		return NULL;
	}
	result = errors;
	return result;
}

TomlValidator*
toml_validator_construct (GType object_type)
{
	TomlValidator* self = NULL;
	self = (TomlValidator*) g_type_create_instance (object_type);
	return self;
}

TomlValidator*
toml_validator_new (void)
{
	return toml_validator_construct (TYPE_TOML_VALIDATOR);
}

static void
value_toml_validator_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_toml_validator_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		toml_validator_unref (value->data[0].v_pointer);
	}
}

static void
value_toml_validator_copy_value (const GValue* src_value,
                                 GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = toml_validator_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_toml_validator_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_toml_validator_collect_value (GValue* value,
                                    guint n_collect_values,
                                    GTypeCValue* collect_values,
                                    guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		TomlValidator * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = toml_validator_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_toml_validator_lcopy_value (const GValue* value,
                                  guint n_collect_values,
                                  GTypeCValue* collect_values,
                                  guint collect_flags)
{
	TomlValidator ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = toml_validator_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_toml_validator (const gchar* name,
                           const gchar* nick,
                           const gchar* blurb,
                           GType object_type,
                           GParamFlags flags)
{
	ParamSpecTomlValidator* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_TOML_VALIDATOR), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_toml_validator (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATOR), NULL);
	return value->data[0].v_pointer;
}

void
value_set_toml_validator (GValue* value,
                          gpointer v_object)
{
	TomlValidator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALIDATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		toml_validator_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_validator_unref (old);
	}
}

void
value_take_toml_validator (GValue* value,
                           gpointer v_object)
{
	TomlValidator * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_TOML_VALIDATOR));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_TOML_VALIDATOR));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		toml_validator_unref (old);
	}
}

static void
toml_validator_class_init (TomlValidatorClass * klass,
                           gpointer klass_data)
{
	toml_validator_parent_class = g_type_class_peek_parent (klass);
	((TomlValidatorClass *) klass)->finalize = toml_validator_finalize;
}

static void
toml_validator_instance_init (TomlValidator * self,
                              gpointer klass)
{
	self->ref_count = 1;
}

static void
toml_validator_finalize (TomlValidator * obj)
{
	TomlValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_TOML_VALIDATOR, TomlValidator);
	g_signal_handlers_destroy (self);
}

static GType
toml_validator_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_toml_validator_init, value_toml_validator_free_value, value_toml_validator_copy_value, value_toml_validator_peek_pointer, "p", value_toml_validator_collect_value, "p", value_toml_validator_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (TomlValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) toml_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (TomlValidator), 0, (GInstanceInitFunc) toml_validator_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType toml_validator_type_id;
	toml_validator_type_id = g_type_register_fundamental (g_type_fundamental_next (), "TomlValidator", &g_define_type_info, &g_define_type_fundamental_info, 0);
	return toml_validator_type_id;
}

GType
toml_validator_get_type (void)
{
	static volatile gsize toml_validator_type_id__once = 0;
	if (g_once_init_enter (&toml_validator_type_id__once)) {
		GType toml_validator_type_id;
		toml_validator_type_id = toml_validator_get_type_once ();
		g_once_init_leave (&toml_validator_type_id__once, toml_validator_type_id);
	}
	return toml_validator_type_id__once;
}

gpointer
toml_validator_ref (gpointer instance)
{
	TomlValidator * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
toml_validator_unref (gpointer instance)
{
	TomlValidator * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		TOML_VALIDATOR_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

